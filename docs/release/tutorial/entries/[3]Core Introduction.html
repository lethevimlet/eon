<!DOCTYPE html>
<html>
<style>
@font-face {
  font-family: 'Roboto';
  font-style: normal;
  font-weight: 400;
  src: url('.././fonts/Roboto/Roboto-Regular.ttf');
}
@font-face {
  font-family: 'Inconsolata';
  font-style: normal;
  font-weight: 400;
  src: url('.././fonts/Inconsolata/Inconsolata-Regular.ttf');
}
body{
    background-color: #fff !important;
      font-family: "Roboto", "Helvetica Neue", Helvetica, Arial, sans-serif !important;
      padding: 0px !important;
      overflow:hidden;
      font-size: 17.5px;
}
.container{
  padding-top:20px;
  padding-right:46px !important;
    margin-left:35px !important;
  width:auto !important;
  position:relative;
  overflow-y:auto;
    height: -webkit-fill-available;
}
.table-striped tbody tr:nth-child(odd) td, .table-striped tbody tr:nth-child(odd) th {
    background-color: #d2d2d2 !important;
}
a{
  color:blue !important;
}
h1, h2, h3, h4, h5, h6{
    text-shadow: none !important;
}
.table {
    border-radius: 0 !important;
    border: 1px solid rgba(0, 0, 0, 0.15) !important;
}
.table-bordered thead:first-child tr:first-child th:first-child, .table-bordered tbody:first-child tr:first-child td:first-child{
    border-radius: 0 !important;
    border: 1px solid rgba(0, 0, 0, 0.15) !important;
}
.table-bordered th, .table-bordered td {
    border-radius: 0 !important;
    border: 1px solid rgba(0, 0, 0, 0.15) !important;
}

.vCodeBlock{
  display: block !important;
  margin-bottom:10px;
  height:auto !important;
    border-radius: 3px;

}
.tip {
    background-color: rgb(36, 36, 41);
    border-radius: 2px;
    padding: 2px 4px;
    color: white;
    display: inline-block;
}
.tip i{
    margin-right:5px;
}

code, pre{
    border: 1px solid rgba(0, 0, 0, 0.15) !important;
    font-family: "Inconsolata", "Helvetica Neue", Helvetica, Arial, sans-serif !important;
    font-size: 17.5px!important;
}
pre code{
  border:none !important;
  font-size: 17.5px!important;
}



/* Perfect scrollbar */
.ps__thumb-y, .ps__thumb-x{
  background-color: #6b6b6b !important;
}
.ps__thumb-y{
width:11px !important;
}
.ps__thumb-x{
height:11px !important;
}
.ps > .ps__rail-x,
.ps > .ps__rail-y {
  background-color:transparent;
  /*  background-color: #d2d2d2 !important;*/
    display: block !important;
}
.ps > .ps__rail-y {
background-color: #cbcbcb !important;
/*  opacity: 0.6;*/
  /*height:100% !important;*/
}



.colorBand{
  width:100%;
  height:5px;
  background-color: #333333;
  margin-top: 50px;
}


video{
  max-width: 100%;
}
.video-js{
  max-width: 100%;
  margin-bottom:20px;
}


.video-js .vjs-big-play-button {
  top:calc(50% - 0.75em) !important;
  left: calc(50% - 1.5em) !important;
}

.selectDisabled {
    -webkit-appearance: none;
    -moz-appearance: none;
    text-indent: 1px;
    text-overflow: '';
}


@font-face {
  font-family: 'Inconsolata';
  font-style: normal;
  font-weight: 400;
  src: url('.././fonts/Inconsolata/Inconsolata-Regular.ttf');
}
.vGround {
  width: 100%;
  margin-bottom:20px;
}
.vGroundMenu {
    box-sizing: border-box;
  display: flex;
  flex-direction: row;
  width: 100%;
  height: 50px;
  align-items: flex-end;
    color: hsl(220, 14%, 71%);
}
.vGroundMenuButton{
  min-width:60px;
    text-align: center;
    padding: 2px 4px;
    box-sizing: border-box;
    cursor:pointer;
    background-color: #fff;
    color: #6b6b6b;
}
.vGroundMenuShowHead{
  margin-left: auto;
   margin-right: 10px; 
}
.vGroundMenuButton:hover{
  color:white;
    background-color:#bebebe;
}
.vGroundMenuActive{
  color:white;
    background-color:#18c796;
}

.vGroundContent {
  font-family: "Inconsolata", "Helvetica Neue", Helvetica, Arial, sans-serif !important;
  width: calc(100% - 12px);
  height: 340px !important;
  border: 1px solid hsl(220, 13%, 18%);
  box-shadow:none;
  border-radius: 0;
  position:relative;
  resize:none;
  display:none;
}

.vGroundIframe{
  font-family: "Inconsolata", "Helvetica Neue", Helvetica, Arial, sans-serif !important;
  width: calc(100% - 12px);
  height: 340px;
    border: 1px solid rgba(0, 0, 0, 0.15);
  box-shadow:none;
  border-radius: 0;
  resize:none;
  background-color:white;
  display:none;
}

.CodeMirror{  
  margin: 0px 0px 10px 0px !important;
}

.cm-s-one-dark .CodeMirror, .cm-s-one-dark .CodeMirror-scroll {
  font-family: "Inconsolata, Monaco, Consolas, "Courier New", Courier"!important;
  /*    font-size: 14px!important;*/
}

.CodeMirror-line {
  border: 0 !important;
}

.CodeMirror textarea {
  display: block !important;
}

.CodeMirror-scroll {
  overflow-x: auto;
  overflow-y: hidden;
  height: auto;
  max-height: 600px;
  cursor: text;
  background-color: hsl(220, 13%, 18%) !important;
  line-height: 100% !important;
}

.cm-s-one-dark .CodeMirror-linenumber {
  min-width: auto !important;
  min-width: 20px !important;
  padding: 0 !important;
  padding-right: 20px !important;
  text-align: right !important;
  white-space: normal !important;
  background-color: hsl(220, 13%, 18%) !important;
}

.CodeMirror-gutters {
  border: none !important;
  background-color: hsl(220, 13%, 18%) !important;
}
.cm-s-one-dark .CodeMirror-linenumber {
  color: #bebebe !important;
  font-size: 14px!important;
}

.vCodeBlock .CodeMirror-cursor {
  display: none !important;
}
.CodeMirror-selected {
  background: hsl(220, 60%, 28%) !important;
}
.cm-s-blackboard .CodeMirror-line::selection, .cm-s-blackboard .CodeMirror-line > span::selection, .cm-s-blackboard .CodeMirror-line > span > span::selection {
background-color:#CC0000 !important;
}

.CodeMirror{  
  margin: 20px 0px;
}
/* As strapdown uses google prettify for code blocks (```code``` and `code`) we need to override
all colors at `code` which will be used as simple text. Code blocks ```code``` will be parsed
via codeMirror */
.pln { color: black !important; }

@media screen {
  .str { color: black !important; }
  .kwd { color: black !important; }
  .com { color: black !important; }
  .typ { color: black !important; }
  .lit { color: black !important; }
  /* punctuation, lisp open bracket, lisp close bracket */
  .pun, .opn, .clo { color: black !important; }
  .tag { color: black !important; }
  .atn { color: black !important; }
  .atv { color: black !important; }
  .dec, .var { color: black !important; }
  .fun { color: color: black !important; }
}


@media print, projection {
  .str { color: black !important; }
  .kwd { color: black !important;}
  .com { color: black !important;}
  .typ { color: black !important;}
  .lit { color: black !important; }
  .pun, .opn, .clo { color: black !important; }
  .tag { color: black !important;}
  .atn { color: black !important; }
  .atv { color: black !important; }
}


h1, h2, h3, h4, h5, h6, p{
  max-width:900px;
}
h1, h2, h3, h4{
  margin: 35px 0px 20px 0px !important;
}
p, ul, .prettyprint lang- prettyprinted{
  font-size: 17.5px;
}
</style>
<xmp theme="slate" style="display:none;">

  

  [Components]<>

## What are vComet components?

vComet components are the individual parts of what your application is composed of, providing both functionality and visuals. With vComet components you can develop an application by composing it of small parts that can be built one at a time, this foments a encapsulated and reusable architecture.

## What can I build with them?

About anything indeed, but most of them fall in one of this three categories, functional components, visual components or a mix of both.

- Functional components - components that provide logic assets, no visuals are involved. An example could be a component that handles websocket connections.

- Visual components - components that provide visual assets, no logic is needed. An example could be a component that handles layout.

- Mixed components - this are by far the most common scenario, where you would like to provide a tied relation between behaviour logic and visual elements.
An example could be a dialog.

Please note this are conceptual definitions, all components are handled in the same way by vComet.

## Advantages of composition

By splitting a complex problem such as an application in small parts or components we can tackle each of them individually, making development cleaner and faster since each part solves an specific part of the puzzle, which can be improved and reused to perfection.

[Usage]<>

vComet imported components can be added **declarative** using html tags or **programmatically** creating and appending elements to the DOM with javascript.

## Import

In order to be able to use vComet components, first they must be imported, since this operation is fully asynchronous its recommend to declare component imports on the `head` section. You may access the a wide library of components under the `ui` directory or any other custom element in a directory of your choice.

<textarea class="vCodeBlock" language="html"><!DOCTYPE html>
<html>
<head>
<title>Page Title</title>

<script>
  vcomet.import("vcomet/ui/vc-button.html");
</script>

...</textarea>

Although the import function can be called multiple times its recommend to follow the following array pattern.

<textarea class="vCodeBlock" language="html"><!DOCTYPE html>
<html>
<head>
<title>Page Title</title>

<script>
  vcomet.import([
    "vcomet/ui/vc-button.html", 
    "vcomet/ui/vc-dialog.html", 
    "vcomet/ui/vc-text.html"
    ]);
</script>

...</textarea>

## Declarative

To use vComet components declaratively simply use their name tag as any other regular html element eg. `<div>, <span>, etc...`

<textarea class="vCodeBlock" language="html"><body>
...

  <vc-button></vc-button>

...</textarea>



## Programmatically

The programmatic approach is preferred when vComet components need to be added or modified on the fly, to achieve this simply create them using the vanilla DOM API.

<textarea class="vCodeBlock" language="html"><script>
  var button = document.createElement("vc-button");
  document.body.appendChild(button);
</script></textarea>

Since imports are asynchronous vComet components properties and functions are declare dynamically and in order to ensure they are accessible we need use a `onCreated` callback.

<textarea class="vCodeBlock" language="html"><script>
  var button = document.createElement("vc-button");
  document.body.appendChild(button);

  button.onCreated(function(){
    this.disable = true;
  });

</script></textarea>

[Creation]<>

Creating your own custom vComet components is a piece of cake!
vComet comes with a full set of well tested and flexible components that will cover most of your needs, but you can easily create your own components too.


## Basic structure

1. Create an empty html file in the desired directory, note `filename must match the tag name of your component in lowercase with at least one hyphen`.

<textarea class="vCodeBlock">ui-custom/my-element.html</textarea>

2. Add `<template>` tag with the desired layout of your component, this is the default content of your vComent component

<textarea class="vCodeBlock" language="html"><template>
  Hello vComet!
</template></textarea>

3. Add `<script>` tag, this is where we will register the behaviour of our element by calling vcomet.element function.

<textarea class="vCodeBlock" language="html"><script>
  vcomet.element("my-element");
</script></textarea>

4. You can also add a `<style>` tag to the file but this is not mandatory specially since most of the style will be handled by the theming mechanism.

<textarea class="vCodeBlock" language="html"><style>
  my-element {
    color: blue;
  }
</style></textarea>

The resultant file `ui-custom/my-element.html` will look something like this:


<textarea class="vCodeBlock" language="html"><style>
  my-element {
    color: blue;
  }
</style>

<template>
  Hello vComet!
</template>

<script>
  vcomet.element("my-element");
</script></textarea>

Now you can use your custom vComet component importing in a declaratively or programmatically way.

## Advanced config

Now we mastered the basics of vComet component creation, we can play with components configuration.
When declaring a new component through `vcomet.element` function you can pass a config object as a second parameter, where properties and functions can be declared and callbacks to element life-cycle can be use to add additional behaviour.

<textarea class="vCodeBlock" language="html"><script>
  vcomet.element("my-element", null, {

    properties: {
      customProperty: "I'm a custom property"
    },

    functions: {
      customFunction: function() {
          console.log("I'm a custom function");
      }
    },

    onReady: function() {
      console.log(this.tagName + " ready!");
    }

  });
</script></textarea>

[Life-cycle]<>

vComet components pass through a series of events that determine their life-cycle. Understanding this events is crucial for an optimal performance implementation. 

## Sequential events

All sequential events are guaranteed to, trigger only once and in order.

Events by execution order:

- **onCreated** - Triggers on element creation, grants access to custom element properties and functions, note at this point the element has no children since its declarative content is temporally stored as a "source" fragment property and the default component layout is also temporally stored as a "template" fragment property.

- **onInit** - Triggers on element first attach and before its transformation.

- **onTransformed** - Triggers after transform, which mean its template fragment and source fragment has been imported to the dom using element slotting approach.

- **onRender** - Triggers after **ALL** elements has been transformed. This is the main event to define element behaviour with trickle flow where parents triggers always before its children.

- **onBubbleRender** - Triggers after **ALL** elements has been transformed and rendered. This is an auxiliary event to define element behaviour with an inverse rendering order. Triggers with a bubble flow where children always triggers before its parents.

- **onReady** - Triggers after all events are completed.

## Recurrent events

Recurrent events might be triggered more than once:

- **onResize** - By default triggers each time window is resized unless element config properties selfResize is set to true, in this case it adds a element resize listener and triggers on element resize. 

- **onAttached** - Triggers each time element is attached to the DOM.

- **onDetached** - Triggers each time element is detached from the DOM.

- **onPropertyChanged** - Triggers each time a property is changed.

- **onAttributeChanged** - Triggers each time an attribute is changed.

- **onDataChanged** - Triggers each time data property is changed.

[Interpolation]<>

vComet template engine makes usage of interpolation in order to provide a powerful and handy way of data binding and scripting.
This allows components to display changeable data in the right place without having to manually update each value. It also provides logic driven content such as conditional or loop based content, in fact it so powerful that any javascript logic can be written inside the interpolation tags and it will be executed in a safe sandboxed environment.


## Basic Usage

Interpolation is represented by `{{ }}` tags and must be written inside the element template. It's also mandatory to set interpolation to 'true' on the element config.

Sometimes specific behaviour can be triggered with the use of shorthands, this are special tokens that are preceded by `{{`. Examples of this are echo shorthand `{{=` and bind shorthand `{{<div class="tip"><i class="fa fa-info"></i><span>.

In order to get started with interpolation we are going to explore a basic data binding example, but note this is just one of its many usages.

Let's create a basic element with interpolation:

hello-world.html</span></div>``[html]
<template>
  Hello {{@ name }}!
</template>

<script>
vcomet.element("hello-world", null, {
  interpolation: true;
  data: {
      name: "World";
  }
});
</script>
<textarea class="vCodeBlock">Now when `<hellow-world></hellow-world>` is used the text 'Hello World' is displayed.

Note that any change on `el.data.name` will immediately get reflected on the text, for example doing something like this:</textarea>[javascript]
var el = document.querySelector("hellow-world");
el.data.name = "Vimlet";
<textarea class="vCodeBlock">would yield the following output instead:</textarea>
Hello Vimlet!
<textarea class="vCodeBlock">## Understanding bind "@"

You can see there's an `<div class="tip"><i class="fa fa-info"></i><span>after the interpolation open tags, this is a shorthand for bind(data) function.
the same code could be written like so without the shorthand:</span></div>``[html]
<template>
  Hello {{ bind("name"); }}!
</template></textarea>

This is possible because vComet template engine treats interpolated code as plain javascript, but provides handy functions like bind(data) and echo(string) as well as its respective shorthands which speeds daily development.

## Understanding echo "="

The function echo(string) outputs text to the template, and it can be used with `=` shorthand.

<textarea class="vCodeBlock" language="html"><template>
  Hello {{ echo("I'm a text"); }}!
</template></textarea>

or simply using its shorthand

<textarea class="vCodeBlock" language="html"><template>
  Hello {{@ "I'm a text" }}!
</template></textarea>

This would be viewed as 

<textarea class="vCodeBlock">Hello I'm a text!</textarea>

## Scripting

Since vComet template engine treats interpolated code as plain sanboxed javascript you can exploit it to your own advantage and create logic based content.

<textarea class="vCodeBlock" language="html"><template>  
  {{
      var text1 = "I'm text1";
      var text2 = "I'm text2";

      for(var i = 0; i < 4; i++) {
          echo(i % 2 == 0 ? text1 : text2);
      }
  }}  
</template></textarea>

This would output

<textarea class="vCodeBlock">I'm text1
I'm text2
I'm text1
I'm text2</textarea>

Interpolated code inside a template share the same scope, so its possible to declare a variable in one block and use it in another.

Its also important to note interpolated code will render only once per element to enhance performance, this wont affect the data bind mechanism.

[Slotting]<>

Many vComet elements can act like containers for other elements and some of this elements need to be placed on a specific part of its container structure.
Placing things on a specific place might be easy programmatically through JavaScript but things get messy quickly when we try to do the same declaratively.
Slotting aims to provide a simple solution to place any element inside its vComet container through the attribute `slot` and CSS selectors.

For example, imagine we had simple container element named 'vc-container':

<textarea class="vCodeBlock" language="html"><template>
  <div class="vc-container-parent"></div>
</template>

<script>
vcomet.element("vc-container");
</script></textarea>

Once imported, in order to use it, we could do this:

<textarea class="vCodeBlock" language="html"><vc-container>
  <span>Hello</span>
</vc-container></textarea>

This would display the element vc-container with a direct child span.
Now lets say we want to place it inside the div with the class vc-container-parent instead. We can do so simply by using the `slot` attribute and a simple css selector.

<textarea class="vCodeBlock" language="html"><vc-container>
  <span slot=".vc-container-parent">Hello</span>
</vc-container></textarea>

vComet takes care of the element placement so you can stay focus on other important aspects of your application.

[Theming]<>

Coming soon...


</xmp>

<script>
// Onload launch strapdown
window.addEventListener('load', function(){
  var strapdown = document.createElement("script");
  strapdown.onload = function(){
    strapdownLoaded();
  };
  strapdown.src = "../framework/strapdown/strapdown.js";
  document.head.appendChild(strapdown);
}, false );

// After strapdown parser launch perfectscrollbar and videojs
function strapdownLoaded() {
  // PerfectScrollbar
  var perfectScrollbarCss = document.createElement("link");
  perfectScrollbarCss.rel = "stylesheet";
  perfectScrollbarCss.href = "../framework/perfectScrollbar/perfect-scrollbar.css";
  document.head.appendChild(perfectScrollbarCss);
  var perfectScrollbarJs = document.createElement("script");
  perfectScrollbarJs.onload = function(){
    perfectScrollbarLoaded();
  };
  perfectScrollbarJs.src = "../framework/perfectScrollbar/perfect-scrollbar.js";
  document.head.appendChild(perfectScrollbarJs);

  // Video.js
  var videoCss = document.createElement("link");
  videoCss.rel = "stylesheet";
  videoCss.href = "../framework/videoJS/videoJS.css";
  document.head.appendChild(videoCss);
  var videoIE = document.createElement("script");
  videoIE.src = "../framework/videoJS/videoJSIE.js";
  document.head.appendChild(videoIE);
  var videoJs = document.createElement("script");
  videoJs.src = "../framework/videoJS/videoJS.js";
  document.body.appendChild(videoJs);

  // FontAwesome
  var fontAwesome = document.createElement("link");
  fontAwesome.rel = "stylesheet";
  fontAwesome.href = "../framework/fontAwesome/css/font-awesome.min.css";
  document.head.appendChild(fontAwesome);

  // CodeMirror
  var cMirrorCss = document.createElement("link");
  cMirrorCss.rel = "stylesheet";
  cMirrorCss.href = "../framework/codeMirror/lib/codemirror.css";
  document.head.appendChild(cMirrorCss);
  var cMirrorTheme = document.createElement("link");
  cMirrorTheme.rel = "stylesheet";
  cMirrorTheme.href = "../framework/codeMirror/theme/one-dark.css";
  document.head.appendChild(cMirrorTheme);
  var cMirrorJs = document.createElement("script");
  cMirrorJs.onload = function(){
    codeMirrorLoaded();
  };
  cMirrorJs.src = "../framework/codeMirror/lib/codemirror.js";
  document.head.appendChild(cMirrorJs);

}

function perfectScrollbarLoaded(){
  var psMD = new PerfectScrollbar('#content');
}

function codeMirrorLoaded(){
  var cMirrorJsMode = document.createElement("script");
  cMirrorJsMode.onload = function(){
    var cMirrorCssMode = document.createElement("script");
    cMirrorCssMode.onload = function(){
      var cMirrorHtmlMode = document.createElement("script");
      cMirrorHtmlMode.onload = function(){
        var cMirrorXmlMode = document.createElement("script");
        cMirrorXmlMode.onload = function(){
          codeMirrorModeLoaded();
        };
        cMirrorXmlMode.src = "../framework/codeMirror/mode/xml/xml.js";
        document.head.appendChild(cMirrorXmlMode);
      };
      cMirrorHtmlMode.src = "../framework/codeMirror/mode/htmlmixed/htmlmixed.js";
      document.head.appendChild(cMirrorHtmlMode);
    };
    cMirrorCssMode.src = "../framework/codeMirror/mode/css/css.js";
    document.head.appendChild(cMirrorCssMode);
  };
  cMirrorJsMode.src = "../framework/codeMirror/mode/javascript/javascript.js";
  document.head.appendChild(cMirrorJsMode);
}

function codeMirrorModeLoaded(){
  var vGrounds = document.querySelectorAll(".vGround");
  vGrounds.forEach(function(vGs){
    var htmlCodeMirror = CodeMirror(function(elt) {
      var vGroundHtml = vGs.querySelectorAll(".vGroundContentHtml")[0];
      vGroundHtml.parentNode.replaceChild(elt, vGroundHtml);
    }, {value: vGs.querySelectorAll(".vGroundContentHtml")[0].value,
    mode: "htmlmixed",
    lineNumbers: true,
    readOnly:false,
    viewportMargin: Infinity,
    theme:"one-dark"
  });
  htmlCodeMirror.display.wrapper.classList.add("vGroundContent");
  htmlCodeMirror.display.wrapper.classList.add("vGroundContentHtml");


  var jsCodeMirror = CodeMirror(function(elt) {
    var vGroundJs = vGs.querySelectorAll(".vGroundContentJs")[0];
    vGroundJs.parentNode.replaceChild(elt, vGroundJs);
  }, {value: vGs.querySelectorAll(".vGroundContentJs")[0].value,
  mode: "javascript",
  lineNumbers: true,
  readOnly:false,
  viewportMargin: Infinity,
  theme:"one-dark"
});
jsCodeMirror.display.wrapper.classList.add("vGroundContent");
jsCodeMirror.display.wrapper.classList.add("vGroundContentJs");


var cssCodeMirror = CodeMirror(function(elt) {
  var vGroundCss = vGs.querySelectorAll(".vGroundContentCss")[0];
  vGroundCss.parentNode.replaceChild(elt, vGroundCss);
}, {value: vGs.querySelectorAll(".vGroundContentCss")[0].value,
mode: "css",
lineNumbers: true,
readOnly:false,
viewportMargin: Infinity,
theme:"one-dark"
});
cssCodeMirror.display.wrapper.classList.add("vGroundContent");
cssCodeMirror.display.wrapper.classList.add("vGroundContentCss");
});

// Initialize playgrounds
initializeIframes();

//Initialize codeBlocks
initCodeBlock();
}

function initCodeBlock(){
  var tidy = true;  //TODO get from md
  var indent = 2; //TODO get from md
  var vCodeBlocks = document.querySelectorAll(".vCodeBlock");
  vCodeBlocks.forEach(function(vCB){
    var cbLanguage = vCB.getAttribute("language") || "htmlmixed";
    if(cbLanguage === "html"){
      cbLanguage = "htmlmixed";
    }
    if(cbLanguage === "js"){
      cbLanguage = "javascript";
    }
    var codeBlockCM = CodeMirror(function(elt) {
      vCB.parentNode.replaceChild(elt, vCB);
    }, {value: vCB.value,
      readOnly:true,
      lineNumbers: true,
      mode: cbLanguage,
      viewportMargin: Infinity,
      theme:"one-dark"
    });
    codeBlockCM.display.wrapper.classList.add("vCodeBlock");
    if(tidy){
    //  codeBlockCM.autoFormatRange({line:0, ch:0}, {line:codeBlockCM.lineCount()});  //TODO no longer exists
    }
  });
}

function initializeIframes(){
  var iframes = document.querySelectorAll(".vGround");
  iframes.forEach(function(ifr){
    var ifrMenu = ifr.querySelector(".vGroundMenu");
    ifrMenu.querySelectorAll(".vGroundMenuButton").forEach(function(menuBtt){
      if(menuBtt.getAttribute("codeType") === "result"){
        vGroundResult(menuBtt);
      }
    });
  });
}

var SHOW_HEAD = "Show head";
var HIDE_HEAD = "Hide head";

function escapeRegExp(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
var headOpen = "<head>";
var headClose = "</head>";
var headRegex = new RegExp(
  escapeRegExp(headOpen) +
  "(?:(?!" +
  escapeRegExp(headOpen) +
  ")[\\s\\S])*" +
  escapeRegExp(headClose) +
  "(\\r\\n|\\r|\\n){0,1}",
  "g"
);

function vGroundHTML(node) {
  toggleShowHead(node, true);
  groundSetActive(node);
}

function vGroundJS(node) {
  toggleShowHead(node, false);
  groundSetActive(node);
}

function vGroundCSS(node) {
  toggleShowHead(node, false);
  groundSetActive(node);
}

function toggleShowHead(node, toggleTo) {
  var showHead = node.parentNode.querySelectorAll(".vGroundMenuShowHead")[0];
  if (toggleTo) {
    showHead.innerHTML = SHOW_HEAD;
    showHead.setAttribute("style", "display:block;");
  } else {
    showHead.setAttribute("style", "display:none;");
  }
}

function showHead(node) {
  htmlMirror = node.parentNode.parentNode.getElementsByClassName("vGroundContentHtml")[0];
  var htmlContent = htmlMirror.CodeMirror.getValue();
  if (node.innerHTML.toLowerCase().includes("show")) {
    var savedHead = htmlMirror.getAttribute("head");
    if (savedHead) {
      savedHead = decodeURIComponent(savedHead).trim() + "\n";
    } else {
      savedHead = "";
    }
    var fullContent = savedHead + htmlContent;
    htmlMirror.CodeMirror.setValue(fullContent);
    setTimeout(() => {
      htmlMirror.CodeMirror.refresh();
    }, 0);
    var showHead = node.parentNode.querySelectorAll(".vGroundMenuShowHead")[0];
    node.innerHTML = HIDE_HEAD;
  } else {
    htmlMirror.CodeMirror.setValue(htmlMirror.CodeMirror.getValue().replace(headRegex, ""));
    setTimeout(() => {
      htmlMirror.CodeMirror.refresh();
    }, 0);
    node.innerHTML = SHOW_HEAD;
  }
}

function vGroundResult(node) {
  toggleShowHead(node, false);
  groundSetActive(node);
  var vGroundContent = node.parentNode.parentNode.getElementsByClassName("vGroundContent")[0];
  var vGroundIframe = node.parentNode.parentNode.getElementsByClassName("vGroundIframe")[0];
  var iframeContent = vGroundIframe.contentWindow.document || vGroundIframe.contentDocument;

  var htmlContent = getHtml(node);

  var iframeSrc = "<!DOCTYPE html><html><head>";
  iframeSrc += getCss(node).outerHTML;

  if (htmlContent.head && htmlContent.head != "") {
    iframeSrc += htmlContent.head;
  } else {
    var commonHead = "";
    htmlMirror = node.parentNode.parentNode.getElementsByClassName("vGroundContentHtml")[0];
    var savedHead = htmlMirror.getAttribute("head");

    if (savedHead) {
      commonHead = decodeURIComponent(savedHead);
    }
    iframeSrc += commonHead.replace(new RegExp("<head>", "g"), "").replace(new RegExp("<\/head>", "g"), "");
  }
  iframeSrc += "</head><body>" + htmlContent.body;

  iframeSrc += getJs(node).outerHTML;

  iframeSrc += "</body></html>";
  
  iframeContent.open();
  iframeContent.write(iframeSrc);
  iframeContent.close();
}

fragmentFromString = function (str) {
  // Test createContextualFragment support
  if (!("__supportsContextualFragment" in window)) {
    try {
      document.createRange().createContextualFragment("test");
      window.__supportsContextualFragment = true;
    } catch (error) {
      window.__supportsContextualFragment = false;
    }
  }
  if (window.__supportsContextualFragment) {
    return document.createRange().createContextualFragment(str);
  } else {
    var temp = document.createElement("template");
    temp.innerHTML = str;
    return temp.content;
  }
};

function getCss(node) {
  var cssContent = node.parentNode.parentNode.getElementsByClassName("vGroundContentCss")[0].CodeMirror.getValue();
  var cssSheet = document.createElement("style");
  cssSheet.rel = "stylesheet";
  cssSheet.innerHTML = cssContent;
  return cssSheet;
}

function getJs(node) {
  var jsContent = node.parentNode.parentNode.getElementsByClassName("vGroundContentJs")[0].CodeMirror.getValue();
  var jsScript = document.createElement("script");
  jsScript.innerHTML = jsContent;
  return jsScript;
}

function getHtml(node) {
  var result = {};
  result.head = "";
  result.body = "";
  var headFound = false;
  var bodyFound = false;
  var htmlContent = node.parentNode.parentNode.getElementsByClassName("vGroundContentHtml")[0].CodeMirror.getValue();
  var headResult = "";
  var headMatches = htmlContent.match(headRegex);
  if (headMatches) {
    headFound = true;
    result.head = cleanMatch(headMatches[0], headOpen, headClose);
  } else {
    if (!node.parentNode.parentNode.getElementsByClassName("vGroundContentHtml")[0].getAttribute("head")) {
      
    }
  }

  var bodyOpen = "<body>";
  var bodyClose = "</body>";
  var bodyRegex = new RegExp(
    escapeRegExp(bodyOpen) +
    "(?:(?!" +
    escapeRegExp(bodyOpen) +
    ")[\\s\\S])*" +
    escapeRegExp(bodyClose) +
    "(\\r\\n|\\r|\\n){0,1}",
    "g"
  );
  var bodyResult = "";
  var bodyMatches = htmlContent.match(bodyRegex);
  if (bodyMatches) {
    bodyFound = true;
    result.body = cleanMatch(bodyMatches[0], bodyOpen, bodyClose);
  }
  if (!headFound && !bodyFound) {
    result.body = htmlContent;
  } else if (headFound && !bodyFound) {
    result.body = htmlContent.replace(headRegex, "");
  }
  return result;
}


function groundSetActive(node) {
  var vGroundContent = node.parentNode.parentNode.getElementsByClassName("vGroundContent");
  var vGroundIframe = node.parentNode.parentNode.getElementsByClassName("vGroundIframe")[0];
  Array.prototype.forEach.call(vGroundContent, function (vGC) {
    vGC.setAttribute("style", "display:none;");
  });
  vGroundIframe.setAttribute("style", "display:none;");
  var codeType = node.getAttribute("codeType");
  switch (codeType) {
    case "result":
      vGroundIframe.setAttribute("style", "display:block;");
      break;
    case "html":
      vGroundContent = node.parentNode.parentNode.getElementsByClassName("vGroundContentHtml")[0];
      var htmlContent = vGroundContent.CodeMirror.getValue();
      var headMatch = htmlContent.match(headRegex);
      if (headMatch) {
        var headContent = headMatch[0];
        vGroundContent.setAttribute("head", encodeURIComponent(headContent));
        htmlContent = htmlContent.replace(headRegex, "");
        vGroundContent.CodeMirror.setValue(htmlContent);
        setTimeout(() => {
          vGroundContent.CodeMirror.refresh();
        }, 0);
      } else {
        if (!vGroundContent.getAttribute("head")) {
          var cHead = null;
          
          if (cHead) {
            vGroundContent.setAttribute("head", encodeURIComponent(cHead));
          }
        }
      }
      vGroundContent.setAttribute("style", "display:block;");
      break;
    case "js":
      vGroundContent = node.parentNode.parentNode.getElementsByClassName("vGroundContentJs")[0];
      vGroundContent.setAttribute("style", "display:block;");
      break;
    case "css":
      vGroundContent = node.parentNode.parentNode.getElementsByClassName("vGroundContentCss")[0];
      vGroundContent.setAttribute("style", "display:block;");
      break;
    default:

  }
  var sibligns = node.parentNode.childNodes;
  sibligns.forEach(function (sibl) {
    sibl.classList.remove("vGroundMenuActive");
  });
  node.classList.add("vGroundMenuActive");
}



function cleanMatch(match, open, close) {
  match = match.trim();
  match = match.substring(open.length, match.length - close.length).trim();
  return match;
}
</script>



</html>
