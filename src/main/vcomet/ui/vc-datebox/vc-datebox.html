<template>

  <div class="vc-datebox-data">
    <label class="vc-datebox-label"></label>
  </div>

  <div class="vc-datebox-main vc-bg2 vc-unselectable">

    <div class="vc-datebox-input">
      <div class="vc-datebox-wrapper">
        <div class="vc-datebox-subInputs">
          <div class="vc-datebox-subInput first">
            <input placeholder="" type="number" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"></input>
          </div>
          <div class="vc-datebox-separator"></div>
          <div class="vc-datebox-subInput second">
            <input placeholder="" type="number" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"></input>
          </div>
          <div class="vc-datebox-separator"></div>
          <div class="vc-datebox-subInput third">
            <input placeholder="" type="number" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"></input>
          </div>
        </div>
        <i class="vc-datebox-button vc-fg2 vc-fg2-hoverable vicon vicon-calendar"></i>
      </div>
      <span class="vc-datebox-underline"></span>
    </div>

  </div>

</template>

<script>
  vcomet.element("vc-datebox", "vc-datebox.css", {
    themed: true,
    privateProperties: {
      /*
      @property (private) {Object} _misc
      @description Object with usefull information
      */
      misc: {
        value: {},
        reflect: false
      },
      /*
      @property (private) {Object} _refs
      @description Object with usefull information
      */
      refs: {
        value: {},
        reflect: false
      },
      /*
      @property (private) {String} _formElement 
      @description Necessary property for a form
      */
      formElement: {
        value: "date"
      }
    },

    properties: {
      /*
      @property {String} name
      @description Name to identify the element in a form
      */
      name: {
        value: "",
        reflect: true
      },
      /*
      @property {String} value
      @description Value of the element
      */
      value: {
        value: "",
        reflect: true
      },
      /*
      @property {String} default
      @description Value of the element when the element is reseted, if will also be the value of the element if no value is provided
      */
      default: {
        value: "",
        reflect: true
      },
      /*
      @property {String} label
      @description Label for the element
      */
      label: {
        value: "",
        reflect: true
      },
      /*
      @property {String} locale
      @description Locale to be used in the datebox
      */
      locale: {
        value: "",
        reflect: true
      },
      /*
      @property {String} mask
      @description Date format of the input
      */
      mask: {
        value: "YYYYMMDD",
        reflect: true
      },
      /*
      @property {String} min
      @description Indicates the inferior limit of the date
      */
      min: {
        value: "",
        reflect: true
      },
      /*
      @property {String} max
      @description Indicates the superior limit of the date
      */
      max: {
        value: "",
        reflect: true
      },
      /*
      @property {Number} pickerFontSize
      @description Indicates the font size of the datepicker
      */
      pickerFontSize: {
        value: 16,
        reflect: true
      },
      /*
      @property {String} pickerSelectable
      @description Indicates the selectable values of the datepicker (day, month and year)
      */
      pickerSelectable: {
        value: "dmy",
        reflect: true
      },
      /*
      @property {String} weekStart
      @description Indicates the first day of the week for the datepicker
      */
      weekStart: {
        value: "monday",
        reflect: true
      },
      /*
      @property {String} weekDaysFormat
      @description Indicates the format of the weekdays header
      */
      weekDaysFormat: {
        value: "short",
        reflect: true
      },
      /*
      @property {String} valueFormat
      @description Indicates the format of the value
      */
      valueFormat: {
        value: "YYYY-MM-DD",
        reflect: true
      },
      /*
      @property {Boolean} toolbar
      @description Indicates whether its in toolbar mode or not
      */
      toolbar: {
        value: false,
        reflect: true
      },
      /*
      @property {Boolean} inline 
      @description Space that occupies the button inside its parent container.
      */
      inline: {
        value: true,
        reflect: true,
        reflectDefault: true
      },
      /*
      @property {Boolean} readonly
      @description Toggles the readonly status of the element
      */
      readonly: {
        value: false,
        reflect: true
      },
      /*
      @property {Boolean} disabled
      @description Toggles the disabled status of the element
      */
      disabled: {
        value: false,
        reflect: true
      },
    },
    privateFunctions: {
      /*
      @function (private) _setup
      @description Here we setup everything we need for the element
      */
      setup: function () {

        var el = this;

        el.locale = (el.locale != undefined && el.locale != "") ? el.locale : navigator.language;

        el._setupMisc();
        el._setupRefs();
        el._setupSeparator();
        el._setupDatePicker();
        el._setupMask();
        el._setupEvents();
        el._setupOverlay();

        el._updateLabel();
        el._updateDisabled();
        el._updateReadOnly();

        if (el.min != "" && el.min != undefined) el._setupMinDate();
        if (el.max != "" && el.max != undefined) el._setupMaxDate();
        if (el.toolbar == "true") el._setupToolbarMode();

        if (vcomet.util.isTouchScreen()) {
          el.dataset.touch = "true";
        }

        el._refs.datePicker.onSelected(function (obj) {
          el._onDatePickerSelection(obj)
        });

        el.setAttribute("valid", "false");

        vcomet.registerPathListener(el, "datebox");

        el._initDefault();
        el._initValue();

      },
      /*
      @function (private) _setupDatePicker
      @description Creates the datePicker and appends it to the datebox
      */
      setupDatePicker: function () {

        var el = this;
        var datePickerElement = document.createElement("vc-datepicker");
        var blurTrigger = vcomet.util.isTouchScreen() ? "touchend" : "click";

        datePickerElement.classList.add("vc-datebox-picker", "hidden");

        datePickerElement.locale = el.locale;
        datePickerElement.weekDaysFormat = el.weekDaysFormat;
        datePickerElement.weekStart = el.weekStart;
        datePickerElement.min = el.min;
        datePickerElement.max = el.max;
        datePickerElement.fontSize = el.pickerFontSize;
        datePickerElement.selectable = el.pickerSelectable;
        datePickerElement.valueFormat = el.valueFormat;

        datePickerElement.onShow(function () {
          el._addFocusStyle();
        });

        datePickerElement.onHide(function () {
          el._removeFocusStyle();
        });

        el._refs.button.addEventListener('click', function (e) {
          if (!vcomet.util.isTrue(el.readonly) && !vcomet.util.isTrue(el.disabled)) {
            el._toggleDatePicker();
          }
        }, false);

        datePickerElement._refs.close.addEventListener('click', function (e) {
          alert("close");
          el._hideDatePicker();
        }, true);

        document.body.addEventListener(blurTrigger, function (e) {
          if (!el.isOnPath && !el._refs.datePicker.isOnPath && !el._refs.overlay.classList.contains("vc-datebox-device")) {
            el._hideDatePicker();
          }
        });

        vcomet.registerPathListener(datePickerElement, "datepicker");

        el._refs.main.appendChild(datePickerElement);

        el._refs.datePicker = datePickerElement;
      },
      /*
      @function (private) _setupOverlay
      @description Sets up basic properties for the data object
      */
      setupOverlay: function () {

        var el = this;

        el._refs.overlay = document.createElement("div");
        el._refs.overlay.classList.add("vc-datebox-overlay");
        el._refs.overlay.classList.add("vc-bg1-modal");
        el._refs.overlay.appendChild(el._refs.datePicker);

        // Prevents scrolling on mobile devices
        window.addEventListener("touchstart", function (e) {
          if (el._misc.modal.active && el._refs.overlay.classList.contains("vc-datebox-device")) {
            e.preventDefault();
          }
        }, { passive: false });

      },
      /*
      @function (private) _setupMisc
      @description Sets up basic properties for the data object
      */
      setupMisc: function () {

        var el = this;

        el._misc.current = {};
        el._misc.mask = {};
        el._misc.min = {};
        el._misc.min.active = false;
        el._misc.max = {};
        el._misc.max.active = false;
        el._misc.modal = {};

      },
      /*
      @function (private) _setupRefs
      @description Creates some fast access elements so that theres no need for calling the QuerySelector all the time.
      */
      setupRefs: function () {

        var el = this;

        el._refs.subInputs = {};

        el._refs.subInputs.first = el.querySelector(".vc-datebox-subInputs .first input");
        el._refs.subInputs.second = el.querySelector(".vc-datebox-subInputs .second input");
        el._refs.subInputs.third = el.querySelector(".vc-datebox-subInputs .third input");

        el._refs.underline = el.querySelector(".vc-datebox-underline");

        el._refs.data = el.querySelector(".vc-datebox-data");
        el._refs.main = el.querySelector(".vc-datebox-main");

        el._refs.button = el.querySelector(".vc-datebox-button");

      },
      /*
      @function (private) _setupMask
      @description Sets up the mask and the subinputs to be used for the user input
      */
      setupMask: function () {

        var el = this;

        el._misc.mask.order = [];

        var dayFormat = el.mask.match(/[d|D]{1,2}/)[0];
        var monthFormat = el.mask.match(/[M]{1,4}/)[0];
        var yearFormat = el.mask.match(/[y|Y]{2,4}/)[0];

        el._misc.mask["day"] = {};
        el._misc.mask["month"] = {};
        el._misc.mask["year"] = {};

        if (dayFormat && monthFormat && yearFormat) {

          var yearOrder = el.mask.indexOf(yearFormat);

          el._misc.mask.day.format = dayFormat;
          el._misc.mask.month.format = monthFormat;
          el._misc.mask.year.format = yearFormat;

          if (el.mask.indexOf(dayFormat) < el.mask.indexOf(monthFormat)) {

            el._misc.mask.order[0] = "day";
            el._misc.mask.order[1] = "month";

          } else {

            el._misc.mask.order[0] = "month";
            el._misc.mask.order[1] = "day";
          }

          if (el.mask.indexOf(yearFormat) < el.mask.indexOf(dayFormat)) {
            el._misc.mask.order.splice(0, 0, "year");
          } else if (el.mask.indexOf(yearFormat) < el.mask.indexOf(monthFormat)) {
            el._misc.mask.order.splice(1, 0, "year");
          } else {
            el._misc.mask.order[2] = "year";
          }

          el.mask = el._misc.mask[el._misc.mask.order[0]].format + el._misc.mask[el._misc.mask.order[1]].format + el._misc.mask[el._misc.mask.order[2]].format;

          el._refs.subInputs.first.placeholder = el._misc.mask[el._misc.mask.order[0]].format;
          el._refs.subInputs.second.placeholder = el._misc.mask[el._misc.mask.order[1]].format;
          el._refs.subInputs.third.placeholder = el._misc.mask[el._misc.mask.order[2]].format;

        } else {

          el._misc.mask.order = ["day", "month", "year"];

          el._misc.mask.day.format = "DD";
          el._misc.mask.month.format = "MM";
          el._misc.mask.year.format = "YYYY";

          el.mask = "DDMMYYYY";

          el._refs.subInputs.first.placeholder = "DD";
          el._refs.subInputs.second.placeholder = "MM";
          el._refs.subInputs.third.placeholder = "YYYY";
        }

        var firstSection = el._misc.mask[el._misc.mask.order[0]];
        var secondSection = el._misc.mask[el._misc.mask.order[1]];
        var thirdSection = el._misc.mask[el._misc.mask.order[2]];

        firstSection.start = 0;
        firstSection.end = el._misc.mask[el._misc.mask.order[0]].format.length;

        secondSection.start = firstSection.end + el._misc.separator.length;
        secondSection.end = secondSection.start + el._misc.mask[el._misc.mask.order[1]].format.length;

        thirdSection.start = secondSection.end + el._misc.separator.length;
        thirdSection.end = thirdSection.start + el._misc.mask[el._misc.mask.order[2]].format.length;

        el._refs.subInputs.first.parentNode.dataset.field = el._misc.mask.order[0];
        el._refs.subInputs.first.parentNode.dataset.order = "0";

        el._refs.subInputs.second.parentNode.dataset.field = el._misc.mask.order[1];
        el._refs.subInputs.second.parentNode.dataset.order = "1";

        el._refs.subInputs.third.parentNode.dataset.field = el._misc.mask.order[2];
        el._refs.subInputs.third.parentNode.dataset.order = "2";

        var separators = el.querySelectorAll(".vc-datebox-subInputs .vc-datebox-separator");

        for (var i = 0; i < separators.length; i++) {
          separators[i].innerHTML = el._misc.separator;
        }

      },
      /*
      @function (private) _setupEvents
      @description Creates the events for the subinputs
      */
      setupEvents: function () {

        var el = this;

        el._setupFocusEvents();
        el._setupBlurEvents();
        el._setupOnKeyDownEvents();
        el._setupOnKeyUpEvents();
        el._setupPasteEvents();

      },
      /*
      @function (private) _setupFocusEvents
      @description Creates the focus events for the subinputs
      */
      setupFocusEvents: function () {

        var el = this;
        el._labelNode = el.querySelector(".vc-datebox-label");

        el._refs.subInputs.first.addEventListener("focus", function (e) {
          if (!vcomet.util.isTrue(el.readonly) && !vcomet.util.isTrue(el.disabled)) {
            el._handleFocus(this);
            el._addFocusStyle();
          }
        }, true);

        el._refs.subInputs.second.addEventListener("focus", function (e) {
          if (!vcomet.util.isTrue(el.readonly) && !vcomet.util.isTrue(el.disabled)) {
            el._handleFocus(el._refs.subInputs.second);
            el._addFocusStyle();
          }
        }, true);

        el._refs.subInputs.third.addEventListener("focus", function (e) {
          if (!vcomet.util.isTrue(el.readonly) && !vcomet.util.isTrue(el.disabled)) {
            el._handleFocus(el._refs.subInputs.third);
            el._addFocusStyle();
          }
        }, true);

      },
      /*
      @function (private) _setupBlurEvents
      @description Sets up the blur events for the subinputs
      */
      setupBlurEvents: function () {

        var el = this;

        el._refs.subInputs.first.addEventListener("blur", function () {

          if ((el._refs.subInputs.first.dataset.field == "day" || el._refs.subInputs.first.dataset.field == "month") && el._refs.subInputs.first.textContent.length == 1 && el._refs.subInputs.first.textContent.length < el._misc.mask[el._misc.mask.order[0]].format.length) {
            el._refs.subInputs.first.textContent = "0" + el._refs.subInputs.first.textContent;
          }

          el._removeFocusStyle();

        }, true);

        el._refs.subInputs.second.addEventListener("blur", function () {

          if ((el._refs.subInputs.second.dataset.field == "day" || el._refs.subInputs.second.dataset.field == "month") && el._refs.subInputs.second.textContent.length == 1 && el._refs.subInputs.second.textContent.length < el._misc.mask[el._misc.mask.order[0]].format.length) {
            el._refs.subInputs.second.textContent = "0" + el._refs.subInputs.second.textContent;
          }

          el._removeFocusStyle();

        }, true);

        el._refs.subInputs.third.addEventListener("blur", function () {

          if ((el._refs.subInputs.third.dataset.field == "day" || el._refs.subInputs.third.dataset.field == "month") && el._refs.subInputs.third.textContent.length == 1 && el._refs.subInputs.third.textContent.length < el._misc.mask[el._misc.mask.order[0]].format.length) {
            el._refs.subInputs.third.textContent = "0" + el._refs.subInputs.third.textContent;
          }

          el._removeFocusStyle();

        }, true);

      },
      /*
      @function (private) _setupOnKeyDownEvents
      @description Sets up the keydown events for the subinputs
      */
      setupOnKeyDownEvents: function () {

        var el = this;

        el._refs.subInputs.first.addEventListener("keydown", function (e) {
          el._handleKeyDown(el._refs.subInputs.first, e);
        }, true);

        el._refs.subInputs.second.addEventListener("keydown", function (e) {
          el._handleKeyDown(el._refs.subInputs.second, e);
        }, true);

        el._refs.subInputs.third.addEventListener("keydown", function (e) {
          el._handleKeyDown(el._refs.subInputs.third, e);
        }, true);

      },
      /*
      @function (private) _setupOnKeyUpEvents
      @description Sets up the keyup events for the subinputs
      */
      setupOnKeyUpEvents: function () {

        var el = this;

        el._refs.subInputs.first.addEventListener("keyup", function (e) {
          el._handleKeyUp(el._refs.subInputs.first, e);
        }, true);

        el._refs.subInputs.second.addEventListener("keyup", function (e) {
          el._handleKeyUp(el._refs.subInputs.second, e);
        }, true);

        el._refs.subInputs.third.addEventListener("keyup", function (e) {
          el._handleKeyUp(el._refs.subInputs.third, e);
        }, true);

      },
      /*
      @function (private) _setupPasteEvents
      @description Sets up the events for the subinputs to prevent paste
      */
      setupPasteEvents: function () {

        var el = this;

        el._refs.subInputs.first.addEventListener("paste", function (e) {
          e.preventDefault;
          return false;
        }, true);

        el._refs.subInputs.second.addEventListener("paste", function (e) {
          e.preventDefault;
          return false;
        }, true);

        el._refs.subInputs.third.addEventListener("paste", function (e) {
          e.preventDefault;
          return false;
        }, true);

      },
      /*
      @function (private) _setupMinDate
      @description Sets up the inferior limit of the date
      */
      setupMinDate: function () {

        var el = this;

        if (el.min.indexOf("/") > -1) {

          var splittedMin = el.min.split("/");

          el._misc.min.day = parseInt(splittedMin[0]);
          el._misc.min.month = parseInt(splittedMin[1]) - 1;
          el._misc.min.year = parseInt(splittedMin[2]);

        } else {

          var date = new Date(parseInt(el.min));

          el._misc.min.day = date.toLocaleString([], {
            day: "numeric"
          });

          el._misc.min.month = date.toLocaleString([], {
            month: "numeric"
          });

          el._misc.min.year = date.toLocaleString([], {
            year: "numeric"
          });
        }

        el._misc.min.active = true;
      },
      /*
      @function (private) _setupMaxDate
      @description Sets up the superior limit of the date
      */
      setupMaxDate: function () {

        var el = this;

        if (el.max.indexOf('/') > -1) {

          var splittedMax = el.max.split("/");

          el._misc.max.day = parseInt(splittedMax[0]);
          el._misc.max.month = parseInt(splittedMax[1]) - 1;
          el._misc.max.year = parseInt(splittedMax[2]);

        } else {

          var date = new Date(parseInt(el.max));

          el._misc.max.day = date.toLocaleString([], {
            day: "numeric"
          });

          el._misc.max.month = date.toLocaleString([], {
            month: "numeric"
          });

          el._misc.max.year = date.toLocaleString([], {
            year: "numeric"
          });
        }

        el._misc.max.active = true;
      },
      /*
      @function (private) {String} _setupSeparator
      @description Takes the value format and saves its separator
      */
      setupSeparator: function () {

        var el = this;

        var format = el.valueFormat;
        var dayFormat = (format.match(/[d|D]{1,2}/)) ? format.match(/[d|D]{1,2}/)[0] : undefined;
        var monthFormat = (format.match(/[M]{1,4}/)) ? format.match(/[M]{1,4}/)[0] : undefined;
        var yearFormat = (format.match(/[y|Y]{2,4}/)) ? format.match(/[y|Y]{2,4}/)[0] : undefined;

        format = format.replace(dayFormat, "");
        format = format.replace(monthFormat, "");
        format = format.replace(yearFormat, "");

        el._misc.separator = format[0];

      },
      /*
      @function (private) _setupToolbarMode
      @description Adds whats needed to overwrite the default style
      */
      setupToolbarMode: function () {
        el._refs.main.classList.add("toolbar");
      },
      /*
      @function (private) _addFocusStyle
      @description When focused, it adds the corresponding style
      */
      addFocusStyle: function () {

        var el = this;

        el._refs.underline.classList.add("animate");
        el.classList.add("focus");
        el._labelNode.classList.add("vc-fg1");

      },
      /*
      @function (private) _addFocusStyle
      @description When focused, it removes the corresponding style
      */
      removeFocusStyle: function () {

        var el = this;

        el._refs.underline.classList.remove("animate");
        el.classList.remove("focus");
        el._labelNode.classList.remove("vc-fg1");

      },
      /*
      @function (private) _toggleDatePicker
      @description Shows/Hides the picker depending on its state
      */
      toggleDatePicker: function () {

        var el = this;

        if (el._refs.datePicker.classList.contains("hidden")) {
          el._showDatePicker();
        } else if (!el._refs.datePicker.classList.contains("hidden")) {
          el._hideDatePicker();
        }

      },
      /*
      @function (private) _showDatePicker
      @description Shows the datepicker
      */
      showDatePicker: function () {

        var el = this;

        el._assignModalStyle();
        el._assignDatePickerStyle();

        el._refs.datePicker._refresh();

        document.body.appendChild(el._refs.overlay);

        el._refs.datePicker._show();

        el._refs.datePicker._handleAutoHeight();
        el._refs.datePicker._handleFonts();

        el._misc.modal.active = true;

        el._misc.modal.windowScrollY = window.scrollY;
        el._misc.modal.windowScrollX = window.scrollX;

      },
      /*
      @function (private) _hideDatePicker
      @description Hides the datepicker
      */
      hideDatePicker: function () {

        var el = this;

        el._refs.datePicker._hide();

        if (el._refs.overlay.parentNode) {
          el._refs.overlay.parentNode.removeChild(el._refs.overlay);
        }

        if (el._misc.modal.active) {
          el._revertModalStyle();
        }

        el._misc.modal.active = false;

      },
      /*
      @function (private) _assignModalStyle
      @description Handles the overlay modal style
      */
      assignModalStyle: function () {

        var el = this;

        // Gets the body style from two different sources
        var computedStyle = window.getComputedStyle(document.body);
        var boundingClientRect = document.body.getBoundingClientRect();

        //  Checks if there are vertical/horizontal scrolls on window
        var windowHasVerticalScroll = (document.body.offsetHeight - window.innerHeight) > 0;
        var windowHasHorizontalScroll = (document.body.offsetWidth - window.innerWidth) > 0;

        // Gets all the margins of the body
        var horizontalMarginSpace = parseFloat(computedStyle.marginLeft) + parseFloat(computedStyle.marginRight) / 2;
        var verticalMarginSpace = parseFloat(computedStyle.marginTop) + parseFloat(computedStyle.marginBottom) / 2;

        var widthDifferenceCalc = (parseInt(boundingClientRect.width) - parseInt(computedStyle.width)) / 2;

        var verticalCalc = parseInt(window.innerWidth + window.pageXOffset + widthDifferenceCalc - document.body.clientWidth);
        var horizontalCalc = parseInt(window.innerHeight - (boundingClientRect.height + boundingClientRect.top));
        var scrollBarWidth = vcomet.util.getBrowserScrollBarWidth();

        el._misc.modal.verticalAdjustement = windowHasVerticalScroll && (verticalCalc >= 0 && verticalCalc <= scrollBarWidth);
        el._misc.modal.horizontalAdjustement = windowHasHorizontalScroll && (horizontalCalc >= 0 && horizontalCalc <= scrollBarWidth);

        // Adjusts the body style to keep it visually intact when adding overflow
        if (el._misc.modal.verticalAdjustement || el._misc.modal.horizontalAdjustement) {

          if (el._misc.modal.verticalAdjustement) {

            // Saves and assigns a width and Left style
            el._misc.modal.previousStyleWidth = parseInt(document.body.style.width);
            el._misc.modal.previousStyleLeft = parseInt(document.body.style.left);

            document.body.style.width = document.body.offsetWidth + "px";
            document.body.style.left = boundingClientRect.left + "px";

          }

          if (el._misc.modal.horizontalAdjustement) {

            // Saves and assigns a top style
            el._misc.modal.previousStyleTop = parseInt(document.body.style.top);
            document.body.style.top = boundingClientRect.top + "px";

          }

          // Saves and assigns a position style
          el._misc.modal.previousStylePosition = document.body.style.position;
          document.body.style.position = "absolute";

          // Shows/Hides the disabled scrollbars in the overlay
          el._refs.overlay.style.overflowY = windowHasVerticalScroll ? "scroll" : "";
          el._refs.overlay.style.overflowX = windowHasHorizontalScroll ? "scroll" : "";

          document.body.classList.add("vc-body-modal");

        }

      },
      /*
      @function (private) _revertModalStyle
      @description Reverts the assigned modal style
      */
      revertModalStyle: function () {

        var el = this;

        document.body.classList.remove("vc-body-modal");

        // Removes the modal style and restores the previous style 
        document.body.style.width = el._misc.modal.previousStyleWidth ? el._misc.modal.previousStyleWidth : "";
        document.body.style.left = el._misc.modal.previousStyleLeft ? el._misc.modal.previousStyleLeft : "";
        document.body.style.top = el._misc.modal.previousStyleTop ? el._misc.modal.previousStyleTop : "";
        document.body.style.position = el._misc.modal.previousStylePosition ? el._misc.modal.previousStylePosition : "";

        el._misc.modal.previousStyleWidth = undefined;
        el._misc.modal.previousStyleLeft = undefined;
        el._misc.modal.previousStyleTop = undefined;
        el._misc.modal.previousStylePosition = undefined;

      },
      /*
      @function (private) _assignDatePickerStyle
      @description Assigns the datePicker's width and position relative to the datebox
      */
      assignDatePickerStyle: function () {

        var el = this;

        if (window.innerWidth <= vcomet.tabletWidth) {

          if (!el._refs.datePicker.classList.contains("vc-datebox-device")) {

            el._refs.datePicker.style.top = "auto";
            el._refs.datePicker.style.left = "auto";

            el._refs.overlay.classList.add("vc-datebox-device")

          }

        } else {

          el._refs.overlay.classList.remove("vc-datebox-device");

          el._refs.datePicker.style.top = el.getBoundingClientRect().top + el.offsetHeight + "px";
          el._refs.datePicker.style.left = el.getBoundingClientRect().left + "px";
          el._refs.datePicker.style.width = el.offsetWidth + "px";
          el._refs.datePicker.style.height = "auto";

        }

      },
      /*
      @function (private) _onDatePickerSelection
      @description Triggered when the user selects a day on the datePicker
      @param {Object} obj
      */
      onDatePickerSelection: function (obj) {

        var el = this;

        el._misc.preventUpdate = true;
        el.value = el._getFormattedValue(obj, el.valueFormat);
        el.setAttribute("valid", true);

        el._misc.current.day = obj.day;
        el._misc.current.month = obj.month;
        el._misc.current.year = obj.year;

        el._refs.subInputs.first.value = obj[el._misc.mask.order[0]];
        el._refs.subInputs.second.value = obj[el._misc.mask.order[1]];
        el._refs.subInputs.third.value = obj[el._misc.mask.order[2]];

        el._hideDatePicker();

      },
      /*
      @function (private) _validateDate
      @description Validates if what the user typed is a valid date
      */
      validateDate: function () {

        var el = this;

        var inputs = el.querySelectorAll(".vc-datebox-subInputs .vc-datebox-subInput input");

        var day = inputs[el._misc.mask.order.indexOf("day")].value;
        var month = inputs[el._misc.mask.order.indexOf("month")].value;
        var year = inputs[el._misc.mask.order.indexOf("year")].value;

        var validDate = false;
        var date;

        var obj = {

          day: day,
          month: month,
          year: year

        }

        //If all the three fields have text typed in and their content is valid we set the boolean to true
        if (year != "") {
          if (month != "" && parseInt(month) > 0 && parseInt(month) <= 12) {
            if (day != "" && day > 0 && day <= vcomet.time.getDaysInMonth(year, parseInt(month) - 1)) {
              validDate = true;
            }
          }
        }

        //If its valid we remove the error classes, and update everything according to the new date
        if (validDate) {

          el.querySelector(".vc-datebox-input").classList.remove("noMatches");
          el._refs.underline.classList.remove("noMatches");

          el._misc.current.day = parseInt(day);
          el._misc.current.month = parseInt(month) - 1;
          el._misc.current.year = parseInt(year);

          el._refs.datePicker._misc.current.day = parseInt(day);
          el._refs.datePicker._misc.current.month = parseInt(month) - 1;
          el._refs.datePicker._misc.current.year = parseInt(year);

          el._refs.datePicker._misc.selected.day = parseInt(day);
          el._refs.datePicker._misc.selected.month = parseInt(month) - 1;
          el._refs.datePicker._misc.selected.year = parseInt(year);

          el._misc.preventUpdate = true;
          el.value = el._getFormattedValue(obj);
          el.setAttribute("valid", "true");

        } else {

          el.querySelector(".vc-datebox-input").classList.add("noMatches");
          el._refs.underline.classList.add("noMatches");

          el._misc.preventUpdate = true;
          el.value = el._getFormattedValue(obj);
          el.setAttribute("valid", "false");

        }

      },
      /*
      @function (private) {Object} _getObjectFromDateString
      @description Given a value with format this functions returns an object with day, month and year provided by the value
      @param {String} value
      */
      getObjectFromDateString: function (value) {

        var el = this;

        var format = el.valueFormat;

        var dayFormat = (format.match(/[d|D]{1,2}/)) ? format.match(/[d|D]{1,2}/)[0] : undefined;
        var monthFormat = (format.match(/[M]{1,4}/)) ? format.match(/[M]{1,4}/)[0] : undefined;
        var yearFormat = (format.match(/[y|Y]{2,4}/)) ? format.match(/[y|Y]{2,4}/)[0] : undefined;

        var splittedValue = value.split(el._misc.separator);
        var splittedFormat = el.valueFormat.split(el._misc.separator);

        var dayIndex = splittedFormat.indexOf(dayFormat);
        var monthIndex = splittedFormat.indexOf(monthFormat);
        var yearIndex = splittedFormat.indexOf(yearFormat);

        return { day: splittedValue[dayIndex], month: splittedValue[monthIndex], year: splittedValue[yearIndex] };

      },
      /*
      @function (private) _initDefault
      @description If a value has been provided by the user we set it for our element
      */
      initDefault: function () {

        var el = this;

        el.value = el.default != "" && el.value == "" ? el.default : el.value;

      },
      /*
      @function (private) _initValue
      @description If a value has been provided by the user we set it for our element
      */
      initValue: function () {

        var el = this;

        if (el.value != "") {

          var splittedMin = el.value.split("/");

          var subInputs = el.querySelector(".vc-datebox-subInputs");
          var dayInput = subInputs.querySelector('[data-field="day"] input');
          var monthInput = subInputs.querySelector('[data-field="month"] input');
          var yearInput = subInputs.querySelector('[data-field="year"] input');

          var valueObj = el._getObjectFromDateString(el.value);

          dayInput.value = valueObj.day;
          monthInput.value = valueObj.month;
          yearInput.value = valueObj.year;

          el._handleLimits(dayInput, monthInput, yearInput);
          el._validateDate();

        }

      },
      /*
      @function (private) _updateLabel
      @description Updates the label node with the new label
      */
      updateLabel: function () {

        var el = this;

        if (el.label != "") {
          el.querySelector(".vc-datebox-label").innerHTML = el.label;
        }

      },
      /*
      @function (private) _updateDisabled
      @description Updates disabled status
      */
      updateDisabled: function () {

        var el = this;

        if (!vcomet.util.isTrue(el.disabled)) {

          el.querySelector(".vc-datebox-subInputs").classList.remove("vc-fg2-disabled");

          el._refs.button.classList.add("vc-fg2");
          el._refs.button.classList.remove("vc-fg2-disabled");

          el._refs.data.classList.remove("vc-fg2-disabled");
          el._refs.main.classList.remove("vc-fg2-disabled");

        } else {

          el.querySelector(".vc-datebox-subInputs").classList.add("vc-fg2-disabled");

          el._refs.button.classList.remove("vc-fg2");
          el._refs.button.classList.add("vc-fg2-disabled");

          el._refs.data.classList.add("vc-fg2-disabled");
          el._refs.main.classList.add("vc-fg2-disabled");

        }
      },
      /*
      @function (private) _updateReadOnly
      @description Updates readonly status
      */
      updateReadOnly: function () {

        var el = this;

        if (vcomet.util.isTrue(el.readonly)) {

          el._refs.subInputs.first.setAttribute("readonly", "true");
          el._refs.subInputs.second.setAttribute("readonly", "true");
          el._refs.subInputs.third.setAttribute("readonly", "true");

          el._refs.button.classList.remove("vc-fg1-hoverable");

        } else {

          el._refs.subInputs.first.removeAttribute("readonly");
          el._refs.subInputs.second.removeAttribute("readonly");
          el._refs.subInputs.third.removeAttribute("readonly");

          el._refs.button.classList.add("vc-fg1-hoverable");

        }

      },
      /*
      @function (private) {String} _getFormattedValue
      @description We replace the format with the given data, in case the field's length is lower than its format then we add 0 as needed
      @param {Object} obj
      */
      getFormattedValue: function (obj) {

        var el = this;
        var format = el.valueFormat;

        var dayFormat = (format.match(/[d|D]{1,2}/)) ? format.match(/[d|D]{1,2}/)[0] : undefined;
        var monthFormat = (format.match(/[M]{1,4}/)) ? format.match(/[M]{1,4}/)[0] : undefined;
        var yearFormat = (format.match(/[y|Y]{2,4}/)) ? format.match(/[y|Y]{2,4}/)[0] : undefined;

        if (obj.day) {

          var day = obj.day;

          day = el._format(day, dayFormat);
          format = format.replace(dayFormat, day);

        }

        if (obj.month) {

          var month = obj.month;

          month = el._format(month, monthFormat);
          format = format.replace(monthFormat, month);

        }

        if (obj.year) {

          var year = obj.year;

          year = el._format(year, yearFormat);
          format = format.replace(yearFormat, year);

        }

        return format;
      },
      /*
      @function (private) {String} _format
      @description We replace the format with the given data, in case the field's length is lower than its format then we add 0 as needed
      @param {String} text
      @param {String} format
      */
      format: function (text, format) {

        var el = this;
        
        text = text ? text + "" : "";

        if (text.length > 0 && text.length < format.length) {
          for (var i = 0; i < (format.length - text.length); i++) {
            text = "0" + text;
          }
        }

        return text;

      },
      /*
      @function (private) {Boolean} _isMinMonth
      @description Returns true if the month is equal/lower than the min month
      @param {Number} year
      @param {Number} month
      */
      isMinMonth: function (year, month) {
        return (year == this._misc.min.year && month <= this._misc.min.month || year < this._misc.min.year);
      },
      /*
      @function (private) {Boolean} _isMaxMonth
      @description Returns true if the month is equal/higher than the max month
      @param {Number} year
      @param {Number} month
      */
      isMaxMonth: function (year, month) {
        return (year == this._misc.max.year && month >= this._misc.max.month || year > this._misc.max.year);
      },
      /*
      @function (private) _handleFocus
      @description Moves the cursor to the right when a subinput is being focused
      @param {Object} subInput
      */
      handleFocus: function (subInput) {
        if (subInput.firstChild) {
          var range = document.createRange();
          var sel = window.getSelection();

          range.selectNodeContents(subInput);

          sel.removeAllRanges();
          sel.addRange(range);

        }
      },
      /*
      @function (private) {Number}  _getCaretPosition
      @description function_description
      @param {Object} editableDiv
      */
      getCaretPosition: function (editableDiv) {
        var caretPos = 0,
          sel, range;
        if (window.getSelection) {
          sel = window.getSelection();
          if (sel.rangeCount) {
            range = sel.getRangeAt(0);
            if (range.commonAncestorContainer.parentNode == editableDiv) {
              caretPos = range.endOffset;
            }
          }
        } else if (document.selection && document.selection.createRange) {
          range = document.selection.createRange();
          if (range.parentElement() == editableDiv) {
            var tempEl = document.createElement("span");
            editableDiv.insertBefore(tempEl, editableDiv.firstChild);
            var tempRange = range.duplicate();
            tempRange.moveToElementText(tempEl);
            tempRange.setEndPoint("EndToEnd", range);
            caretPos = tempRange.text.length;
          }
        }
        return caretPos;
      },
      /*
      @function (private) {Boolean} _isNumeric
      @description Whether the recieved key event has a numeric value or not
      @param {Object} e
      */
      isNumeric: function (e) {
        return (e.keyCode >= 48 && e.keyCode <= 57) || (e.keyCode >= 96 && e.keyCode <= 105);
      },
      /*
      @function (private) _handleKeyDown
      @description Handles the typing and the date correction, if the subinput reaches its limit it jumpes to the next one
      @param {Object} subInput
      @param {Object} e
      */
      handleKeyDown: function (subInput, e) {

        var el = this;
        var selection = window.getSelection();

        if (!el._isNumeric(e)) {

          if (e.keyCode != "9" && e.keyCode != "46" && e.keyCode != "8" && e.keyCode != "37" && e.keyCode != "39") {

            e.preventDefault();
            e.stopPropagation();

          } else {

            if (e.keyCode == "8") {

              var subInputs = el.querySelector(".vc-datebox-subInputs");
              var previousSubInputOrder = parseInt(subInput.parentNode.dataset.order) - 1;
              var previousSubInput = subInputs.querySelector('[data-order="' + previousSubInputOrder + '"] input');
              var caretPosition = subInput.selectionStart;

              if (!(selection.anchorNode === subInput && selection.extentOffset > 0 && selection.type == "Range")) {
                if (caretPosition == 0 && previousSubInput) {
                  previousSubInput.focus();
                }

              }

            }

          }
        } else {

          var subInputs = el.querySelector(".vc-datebox-subInputs");

          var nextSubInputOrder = parseInt(subInput.dataset.order) + 1;
          var nextSubInput = subInputs.querySelector('[data-order="' + nextSubInputOrder + '"] input');

          var aux = subInput.value;

          if (!(selection.anchorNode === subInput && selection.extentOffset > 0 && selection.type == "Range")) {

            if (!(aux.length >= el._misc.mask[subInput.parentNode.dataset.field].format.length)) {
              subInput.value = aux + el._getStringFromKeyCode(e.keyCode);
              e.preventDefault();
              e.stopPropagation();
            }


          }

        }

        // Checks if the key press corresponds to ENTER
        if (e.keyCode == 13) {
          vcomet.triggerCallback("onEnter", el)
        }

      },
      /*
      @function (private) {String} _getStringFromKeyCode
      @description Receives a keyCode and returns the string value (intented for numeric)
      @param {String} keyCode
      */
      getStringFromKeyCode: function (keyCode) {
        return String.fromCharCode((keyCode >= 96 && keyCode <= 105) ? keyCode - 48 : keyCode)
      },
      /*
      @function (private) _handleKeyUp
      @description Handles the key up event
      @param {Object} subInput 
      @param {Object} e [event]
      */
      handleKeyUp: function (subInput, e) {

        var el = this;

        if (!(document.activeElement.isEqualNode(subInput) && el._getSelectionText().length == subInput.value.length)) {

          if (el._isNumeric(e) || e.keyCode == "8" || e.keyCode == "46") {

            var subInputs = el.querySelector(".vc-datebox-subInputs");

            var nextSubInputOrder = parseInt(subInput.parentNode.dataset.order) + 1;
            var nextSubInput = subInputs.querySelector('[data-order="' + nextSubInputOrder + '"] input');

            if ((subInput.value.length >= el._misc.mask[subInput.parentNode.dataset.field].format.length)) {

              if (nextSubInput) {
                nextSubInput.focus();
              }

              el._handleCorrection();
            }

            el._validateDate();

          }

        }

      },
      /*
      @function (private) {String} _getSelectionText
      @description Gets the selected text
      */
      getSelectionText: function () {
        var text = "";
        var activeEl = document.activeElement;
        var activeElTagName = activeEl ? activeEl.tagName.toLowerCase() : null;
        if (
          (activeElTagName == "textarea") || (activeElTagName == "input" &&
            /^(?:text|search|password|tel|url)$/i.test(activeEl.type)) &&
          (typeof activeEl.selectionStart == "number")
        ) {
          text = activeEl.value.slice(activeEl.selectionStart, activeEl.selectionEnd);
        } else if (window.getSelection) {
          text = window.getSelection().toString();
        }
        return text;
      },
      /*
      @function (private) _handleCorrection
      @description Handles the date correction for months and days
      */
      handleCorrection: function () {

        var el = this;

        var subInputs = el.querySelector(".vc-datebox-subInputs");

        var dayInput = subInputs.querySelector('[data-field="day"] input');
        var monthInput = subInputs.querySelector('[data-field="month"] input');
        var yearInput = subInputs.querySelector('[data-field="year"] input');

        if (dayInput.value != "" && parseInt(dayInput.value) > 31) {
          dayInput.value = "31";
        } else if (dayInput.value.length == 2 && parseInt(dayInput.value) == 0) {
          dayInput.value = "1";
        }

        if (monthInput.value != "" && parseInt(monthInput.value) > 12) {
          monthInput.value = "12";
        } else if (monthInput.value.length == 2 && parseInt(monthInput.value) == 0) {
          monthInput.value = "1";
        }

        if (yearInput.value != "" && parseInt(yearInput.value) > 9999) {
          yearInput.value = "9999";
        } else if (parseInt(yearInput.value) == 0) {
          yearInput.value = "1";
        }

        if (dayInput.value != "" && monthInput.value != "" && yearInput.value != "" && (yearInput.value.length == el._misc.mask.year.format.length)) {
          if (parseInt(dayInput.value) > vcomet.time.getDaysInMonth(parseInt(yearInput.value), parseInt(monthInput.value) - 1)) {
            dayInput.value = vcomet.time.getDaysInMonth(parseInt(yearInput.value), parseInt(monthInput.value) - 1);
          }
        }

        el._handleLimits(dayInput, monthInput, yearInput);
      },
      /*
      @function (private) _handleLimits
      @description Handles the limits such as min/max date
      @param {Object} dayInput
      @param {Object} monthInput
      @param {Object} yearInput
      */
      handleLimits: function (dayInput, monthInput, yearInput) {

        var el = this;

        if (dayInput.value != "" && monthInput.value != "" && yearInput.value != "" && yearInput.value.length == el._misc.mask.year.format.length) {

          var dayInputValue = parseInt(dayInput.value);
          var monthInputValue = parseInt(monthInput.value);
          var yearInputValue = parseInt(yearInput.value);

          if ((dayInputValue < el._misc.min.day && monthInputValue <= el._misc.min.month && yearInputValue == el._misc.min.year) || (monthInputValue < el._misc.min.month && yearInputValue == el._misc.min.year) || yearInputValue < el._misc.min.year) {

            dayInput.value = el._misc.min.day;
            monthInput.value = parseInt(el._misc.min.month) + 1;
            yearInput.value = el._misc.min.year;

          } else if ((dayInputValue > el._misc.max.day && monthInputValue >= el._misc.max.month && yearInputValue == el._misc.max.year) || (monthInputValue > el._misc.max.month && yearInputValue == el._misc.max.year) || yearInputValue > el._misc.max.year) {

            dayInput.value = el._misc.max.day;
            monthInput.value = parseInt(el._misc.max.month) + 1;
            yearInput.value = el._misc.max.year;
          }
        }
      },
      /*
      @function (private) _updateValue
      @description Allows the user tu set a new value to the element
      @param {Object} value
      */
      updateValue: function () {

        var el = this;

        if (!el._misc.preventUpdate) {

          var format = el.valueFormat;

          var subInputs = el.querySelector(".vc-datebox-subInputs");
          var dayInput = subInputs.querySelector('[data-field="day"] input');
          var monthInput = subInputs.querySelector('[data-field="month"] input');
          var yearInput = subInputs.querySelector('[data-field="year"] input');

          var value = el.value;

          var valueObj, day, month, year;

          if (value.constructor == Date) {

            day = value.toLocaleString([], {
              day: "numeric"
            });

            month = value.toLocaleString([], {
              month: "numeric"
            });

            year = value.toLocaleString([], {
              year: "numeric"
            });

            valueObj = {
              day: day,
              month: month,
              year: year
            }

          } else {

            valueObj = el._getObjectFromDateString(el.value);

          }

          el._misc.current.day = el._format(valueObj.day, el._misc.mask.day.format);
          el._misc.current.month = el._format(valueObj.month, el._misc.mask.month.format);
          el._misc.current.year = el._format(valueObj.year, el._misc.mask.year.format);

          if (el._refs.datePicker) {
            
            el._refs.datePicker._misc.current.day = el._misc.current.day ? el._misc.current.day : el._refs.datePicker._misc.current.day;
            el._refs.datePicker._misc.current.month = el._misc.current.month ? el._misc.current.month : el._refs.datePicker._misc.current.month;
            el._refs.datePicker._misc.current.year = el._misc.current.year ? el._misc.current.year : el._refs.datePicker._misc.current.year;

            el._refs.datePicker._misc.selected.day = el._misc.current.day;
            el._refs.datePicker._misc.selected.month = el._misc.current.month;
            el._refs.datePicker._misc.selected.year = el._misc.current.year;

          }

          dayInput.value = el._misc.current.day;
          monthInput.value = el._misc.current.month;
          yearInput.value = el._misc.current.year;

          el._handleLimits(dayInput, monthInput, yearInput);
          el._validateDate();

        }

        el._misc.preventUpdate = false;

      }
    },
    functions: {
      clear: function () {
        this.value = "";
      },
      reset: function () {

        var el = this;

        if (el.default != "") {
          el.value = el.default;
        } else {
          el.clear();
        }

      }
    },
    onCreated: function () {
      vcomet.createCallback("onEnter", this);
    },
    onRender: function () {
      this._setup();
    },
    onPropertyChanged: function (key, oldVal, newVal) {

      switch (key) {
        case "label":
          this._updateLabel();
          break;
        case "disabled":
          this._updateDisabled();
          break;
        case "readonly":
          this._updateReadOnly();
          break;
        case "value":
          this._updateValue();
          break;
      }

    },
    onWindowResize: function () {

      var el = this;

      if (el._refs.datePicker && !el._refs.datePicker.classList.contains("hidden")) {
        el._hideDatePicker();
      }

    }
  });

</script>