<script>
  vcomet.element("vc-panel", "", {
    dependencies: [
      "../vc-scroll"
    ],
    privateProperties: {
      /*
        @property (private) {Object} _refs 
        @description Quick access to the panel structure nodes references
      */
      refs: {
        value: {}
      }
    },
    properties: {
      /*
        @property {String} href
        @description External panel content URL
      */
      href: {
        value: "",
        reflect: true
      },
      /*
        @property {Boolean} allowScroll
        @description Allow or denied scroll
      */
      allowScroll: {
        value: true,
        reflect: true
      },
      /*
        @property {Object} content
        @description Content container node reference
      */
      content: {
        value: {}
      },
      /*
        @property {Object} fit
        @description Indicates whether the vc-scroll will autofill its container or grow according to its content until it fills its container
        Values true, false
        Default: false
      */
      fit: {
        value: false,
        reflect: true
      },
      /*
        @property {Boolean} arrowScrolls
        @description Indicates the vc-scroll whether it needs arrow scrolls or not
        Values true, false
        Default: false
      */
      arrowScrolls: {
        value: false,
        reflect: true
      },
      /*
      @property {String} name
      @description In case of being used in vc-tabs it will be used internally to link a tab to its panel
      */
      name: {
        value: "",
        reflect: true
      },
      /*
      @property {String} tabTitle
      @description In case of being used in vc-tabs , it will be used as a visual text for the tab
      */
      tabTitle: {
        value: "",
        reflect: true
      }
    },
    privateFunctions: {
      /*
        @function (private) importContent
        @description Set panel content form local or remote html
      */
      importContent: function () {
        var el = this;
        // Get panel elements
        var documentFragment = document.createDocumentFragment();
        // Check href property
        if (el.href) {
          // Request content file
          var xhr = new XMLHttpRequest();
          xhr.open("GET", el.href, true);
          xhr.setRequestHeader("Content-Type", "application/json");
          // Callback
          xhr.onload = function (e) {
            // If operation has been completed - ready state 4
            if (this.readyState !== 4) { return };
            // Response status successfully completed - status 200
            if (this.status !== 200) { return };
            // Allow execute imported html scripts
            documentFragment = vcomet.fragmentFromString(xhr.responseText);
            el._appendContent(documentFragment);
          };
          // Execute request
          xhr.send();
        } else {
          // Store templates references
          el._appendContent(el);
        }
      },
      /*
        @function (private) appendContent
        @description Append content to the panel or the scroll container if exists 
        @param {Object} dataNode [Node element containing the panel content]
      */
      appendContent: function (dataNode) {
        var el = this;
        var fragment = document.createDocumentFragment();
        var i, t;
        var reAppend = el.href || vcomet.util.isTrue(el.allowScroll);
        var childrenArray;
        // ** IE do not support 'children' property
        if(vcomet.util.getBrowser() === "IE"){
          // Avoid empty element template on programmatic cases
          childrenArray = !dataNode.childNodes[0] ? dataNode.template.childNodes : dataNode.childNodes;
          // From node list to js array
        } else {
          // Avoid empty element template on programmatic cases
          childrenArray = !dataNode.children[0] ? dataNode.template.children : dataNode.children;
        }

        childrenArray = [].slice.call(childrenArray);
        // Get first generation template children
        while (childrenArray.length) {
          // Build nodes structure
          child = childrenArray.shift();
          if(child.nodeType == 1) {
            // Append remote source child
            if (reAppend) {
              fragment.appendChild(child);
            }
            if (child.tagName.toLowerCase() === "template") {
              // Store templates references
              el._refs.templates[t] = child;
              t++
            }
          }
        }
        // Move templates to the assigned body container 
        if (reAppend) {
           el.content.appendChild(fragment);
        }

        vcomet.triggerCallback("onLoad", el, el, []);
      },
      /*
        @function (private) removeTemplate
        @description Extract content and remove the template node
        @param {Object} tmp [Node element containing the panel content]
      */
      removeTemplate: function (tmp) {
        var el = this;
        var fragment = document.createDocumentFragment();
        var child;
        var children = !tmp.children[0] ? tmp.content.children: tmp.children;
        children = [].slice.call(children);
        // Move nodes to the tree container safely
        while (children.length) {
          // Build nodes structure
          child = children.shift();
          fragment.appendChild(child);
        }
        // Insert template content just before the template node
        el.content.insertBefore(fragment, tmp);
        // Remove empty template
        el.content.removeChild(tmp);
      },
      /*
        @function (private) setUpScroll
        @description 
      */
      setUpScroll: function () {
        var el = this;
        // Set passed scroll parameters
        el._refs.wrapper.fit = el.fit;
        el._refs.wrapper.arrowScrolls = el.arrowScrolls;
      }
    },
    functions: {
      /*
        @function render
        @description Extract content from template and remove it from DOM
        @param {Object} index [Template identifier]
      */
      render: function (index) {
        var el = this;
        var tmp, i;
        var tmps = el._refs.templates;
        
        // Partial render
        if (index === 0 || index) {
          tmp = tmps[index];
          // Remove template
          el._removeTemplate(tmp);
          delete tmps[index];
        } else {
          var keys = Object.keys(tmps);
          
          for (i = 0; i < keys.length; i++) {
            tmp = tmps[keys[i]];
            // Remove template
            el._removeTemplate(tmp);
            delete tmps[keys[i]];
          }
        }
      },
      /*
        @function refresh
        @description Remove current content and re-import content
      */
      refresh: function () {
        var el = this;
        // Remove previous content 
        el._refs.wrapper.content.innerHTML = "";

        // Import panel content from specific source
        el._importContent();
      }
    },
    onCreated: function () {
      var el = this;
      // Create content related callbacks
      vcomet.createCallback("onLoad", this);
      vcomet.createCallback("onContent", this);
      el._refs.templates = {};
      // Get body container
      if(vcomet.util.isTrue(el.allowScroll)) {
        el._refs.wrapper = document.createElement("vc-scroll");
        // Configure scroll
        el._setUpScroll();
      } else {
        el._refs.wrapper = el;
      }
      // Get body container
      el.content = vcomet.util.isTrue(el.allowScroll) ? el._refs.wrapper.content : el;
    },
    onTransformed: function () {
      var el = this;
      // Import panel content from specific source
      el._importContent();

      if (!el._refs.wrapper.isEqualNode(el)) { el.appendChild(el._refs.wrapper) }
    }
  });
</script>