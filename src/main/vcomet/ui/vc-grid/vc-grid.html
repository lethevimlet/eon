<template>

    <div class="vc-grid-header">
        <div class="vc-grid-wrapper vc-sect1"></div>
    </div>

    <div class="vc-grid-rows">
        <vc-scroll thickness="10" rail-scrolls="false">
            <div class="vc-grid-wrapper">
            </div>
        </vc-scroll>
    </div>

    <div class="vc-grid-footer vc-fg1 vc-sect1 vc-unselectable">
        <div class="vc-grid-pagControls vc-fg5">
            <i class="vicon vicon-arrow-back vc-grid-pagIcon vc-fg1-hoverable" data-navigation="first"></i>
            <i class="vicon vicon-chevron-left vc-grid-pagIcon vc-fg1-hoverable" data-navigation="previous"></i>
            <div class="pageSelector"></div>
            <i class="vicon vicon-chevron-right vc-grid-pagIcon vc-fg1-hoverable" data-navigation="next"></i>
            <i class="vicon vicon-arrow-forward vc-grid-pagIcon vc-fg1-hoverable" data-navigation="last"></i>
        </div>
        <span class="vc-grid-entriesCount vc-fg5"></span>
    </div>

</template>

<script type="text/javascript">
    vcomet.element("vc-grid", "vc-grid.css", {
        themed: true,
        dependencies: [
            "../vc-row",
            "../vc-cell",
            "../vc-scroll"
        ],
        privateProperties: {
            /*
            @property (private) {Object} _misc
            @description Object with miscellaneous data
            */
            misc: {
                value: {},
                reflect: false
            },
            /*
            @property (private) {Object} _refs
            @description Object with references
            */
            refs: {
                value: {},
                reflect: false
            },
        },

        properties: {
            /*
            @property {Boolean} footer
            @description Whether the footer will be displayed or not
            */
            footer: {
                value: true,
                reflect: true
            },
            /*
            @property {String} pagination
            @description Defines the type of the page pagination
            */
            pagination: {
                value: "",
                reflect: true
            },
            /*
            @property {Boolean} entriesCount
            @description Whether the footer will display the page entries or not
            */
            entriesCount: {
                value: false,
                reflect: true
            },
            /*
            @property {String} columns
            @description Defines the columns that will be shown in the grid
            */
            columns: {
                value: "",
                reflect: true
            },
            /*
            @property {String} headers
            @description Defines the headers of the given columns
            */
            headers: {
                value: "",
                reflect: true
            },
            /*
            @property {String} String
            @description It can be a number of max rows of the page, or automatic
            */
            pageSize: {
                value: "auto",
                reflect: true
            },
            /*
            @property {Boolean} autofit
            @description Whether the grid will manage the rows amount depending on the available space
            */
            autofit: {
                value: "true",
                reflect: true
            },
            /*
            @property {Boolean} resizable
            @description Whether the user can resize the columns or not
            */
            resizable: {
                value: true,
                reflect: true
            },
            /*
            @property {Number} columnMinWidth
            @description Pixels that will be set as the minimum width of each column
            */
            columnMinWidth: {
                value: 150,
                reflect: true
            },
            /*
            @property {Number} rowMinHeight
            @description Pixels that will be set as the minimum height of each row
            */
            rowMinHeight: {
                value: 52,
                reflect: true
            },
            /*
            @property {Boolean} editable
            @description Whether the user will be able to edit entry cells or not
            */
            editable: {
                value: "false",
                reflect: true
            },
            /*
            @property {String} idProperty
            @description This property will be transfered to the store
            */
            idProperty: {
                value: "",
                reflect: true
            },
            /*
              @property {Boolean} fill 
              @description 
              Values: true, false
              Default: true
            */
            fill: {
                value: true,
                reflect: true
            }
        },

        privateFunctions: {
            /*
            @function (private) _setupRefs
            @description Creates some fast access elements so that theres no need for calling the QuerySelector all the time.
            */
            setupRefs: function () {

                var el = this;

                el._refs.header = el.template.querySelector(".vc-grid-header");
                el._refs.headersWrapper = el.template.querySelector(".vc-grid-header .vc-grid-wrapper");
                el._refs.rowsWrapper = el.template.querySelector(".vc-grid-rows .vc-grid-wrapper");
                el._refs.footer = el.template.querySelector(".vc-grid-footer");

                el._refs.scroll = el.template.querySelector("vc-scroll");

                el._refs.pageSelector = el.template.querySelector(".pageSelector");
                el._refs.entriesCount = el.template.querySelector(".vc-grid-entriesCount");

                el.store = new vcomet.store();

            },
            /*
            @function (private) _setupMisc
            @description Sets up basic properties for the misc object
            */
            setupMisc: function () {

                var el = this;

                el._misc.columns = {};
                el._misc.range = {};
                el._misc.entriesCount = 0;

                el._misc.resize = {};
                el._misc.resize.active = false;
                el._misc.resize.firstTime = true;

                el._misc.sourceFragment = document.createDocumentFragment();

                el._misc.currentPage = 1;
                el._misc.hasPagination = true;
                el._misc.isEditing = false;

            },
            /*
            @function (private) _setupHeaders
            @description Creation of the headers and its attributes
            */
            setupHeaders: function () {

                var el = this;

                var header = el.querySelector(".vc-grid-header .vc-grid-wrapper");
                var columnsKeys = Object.keys(el._misc.columns);
                var docFragment = document.createDocumentFragment();
                var headerCell;
                var headerResize;

                header.classList.add("headers");

                //Create header for each column
                for (var i = 0; i < columnsKeys.length; i++) {
                    headerCell = document.createElement("vc-cell");

                    if (el._misc.columns[columnsKeys[i]].class) {
                        headerCell.classList.add(el._misc.columns[columnsKeys[i]].class);
                    }

                    headerCell.classList.add("vc-grid-" + columnsKeys[i] + "Column");

                    //Adding Attributes to the header
                    headerCell.setAttribute("type", "header");
                    headerCell.setAttribute("sort", "none");
                    headerCell.setAttribute("fixed", "false")
                    headerCell.setAttribute("column", el._misc.columns[columnsKeys[i]].name);
                    headerCell.setAttribute("order", el._misc.columns[columnsKeys[i]].order);
                    headerCell.content.innerHTML = el._misc.columns[columnsKeys[i]].header;
                    headerCell.onclick = function (e) {
                        el._sort(e, this)
                    };

                    docFragment.appendChild(headerCell);

                    //If he grid columns are resizable then we will create a resize Indicator for every columns
                    //except for the last one
                    if ((el.resizable == "true" || el.resizable == true)) {

                        headerResize = document.createElement("div");

                        headerResize.classList.add("vc-grid-resizeIndicator");
                        headerResize.dataset.columnTarget = i;

                        headerResize.onmousedown = function (e) {

                            if (e.button == 0) {

                                el._misc.resize.initialPosition = el._misc.resize.initialPosition || {};
                                el._misc.resize.initialPosition.x = e.clientX;
                                el._misc.resize.initialPosition.y = e.clientY;

                                el._resizeColumn(this);

                            }
                        };

                        headerCell.appendChild(headerResize);
                    }
                }

                header.appendChild(docFragment);
            },
            /*
            @function (private) _setupColumns
            @description Sets up the columns and its css rule
            */
            setupColumns: function () {

                var el = this;

                var columns = el.columns.substring(0, 1) == "[" ? eval(el.columns) : el.columns.replace(/\s/g, '').split(',');
                var headers = el.headers.length > 0 && el.headers.substring(0, 1) == "[" ? eval(el.headers) : el.headers.replace(/\s/g, '').split(',');
                var layoutWidth = 0;
                var newStyle = document.createElement("style");

                var sheet, rulePosition, columnRule, columnName, columnHeader;

                //If there are no headers specified or the amount of headers is not the same as columns,
                //then we equal the headers to the columns
                headers = (headers.length == 0 || (headers.length < 0 && columns.length != headers.length)) ? columns : headers;

                el._refs.header.insertBefore(newStyle, el._refs.header.childNodes[0]);
                sheet = newStyle.sheet;

                for (var i = 0; i < columns.length; i++) {

                    columnName = columns[i].constructor === Object ? columns[i].name : columns[i];
                    columnHeader = columns[i].constructor === Object && columns[i].header ? columns[i].header : headers[i];
                    columnContent = columns[i].constructor === Object && columns[i].content ? columns[i].content : false;
                    columnClass = columns[i].constructor === Object && columns[i].class ? columns[i].class : false;
                    columnMinWidth = columns[i].constructor === Object && columns[i].minWidth ? columns[i].minWidth : el.columnMinWidth;
                    columnEditable = columns[i].constructor === Object && columns[i].hasOwnProperty("editable") ? vcomet.util.isTrue(columns[i].editable) : (vcomet.util.isTrue(el.editable));

                    // Layout related, creates the column rule
                    rulePosition = sheet.cssRules.length;
                    sheet.insertRule("vc-grid[uid='" + el.uid + "'] vc-cell.vc-grid-" + columnName + "Column {}", rulePosition);
                    columnRule = sheet.cssRules[rulePosition];
                    columnRule.style.minWidth = columnMinWidth + "px";
                    layoutWidth = layoutWidth + parseInt(columnMinWidth);

                    // Saves all the column information
                    el._misc.columns[columnName] = {};
                    el._misc.columns[columnName]["name"] = columnName;
                    el._misc.columns[columnName]["header"] = columnHeader;
                    el._misc.columns[columnName]["content"] = columnContent;
                    el._misc.columns[columnName]["order"] = i;
                    el._misc.columns[columnName]["rule"] = columnRule;
                    el._misc.columns[columnName]["class"] = columnClass;
                    el._misc.columns[columnName]["editable"] = columnEditable;

                }

                el._refs.headersWrapper.style.minWidth = layoutWidth + "px";
                el._refs.headersWrapper.style.width = "auto";

                el._refs.rowsWrapper.style.minWidth = layoutWidth + "px";
                el._refs.rowsWrapper.style.width = "auto";

            },
            /*
            @function (private) _setupPageSize
            @description Setting up the rows size type depending on the user input
            */
            setupPageSize: function () {

                var el = this;

                if (parseInt(el.pageSize)) {

                    el._misc.pagingType = "fixed";
                    el._misc.pageSize = parseInt(el.pageSize);

                } else {

                    if (!el.pageSize || el.pageSize == "auto") {

                        el._misc.pagingType = "auto";
                        el._misc.pageSize = el._getRowsCapacity();

                    } else if (el.pageSize == "all") {

                        el._misc.pagingType = "all";
                        el._misc.pageSize = 0;

                    }

                }

            },
            /*
            @function (private) _setupContent
            @description Depending on what the user provided with the grid we will set up our store with the data we have
            */
            setupContent: function () {

                var el = this;

                // var myCallback = function () {

                //     el._misc.pageSize = el._misc.pagingType == "all" ? el.store.size : el._misc.pageSize;

                //     var start = 1;
                //     var limit = parseInt(el._misc.pageSize);

                //     el._handleEntries("object", true, start, limit);
                //     el._updatePagination(1);

                // };

                //Store calls
                el.store.onLoaded(function () {

                    var start = 1;
                    var limit = parseInt(el._misc.pageSize);
                    var rowsData = el._generateSourceRowsData();
                    
                    if (rowsData && Object.keys(rowsData).length > 0) {
                        console.log('rowsData', rowsData);
                        el.store.data = rowsData;
                    }

                    el._misc.pageSize = el._misc.pagingType == "all" ? el.store.size : el._misc.pageSize;

                    el._handleEntries("object", true, start, limit);
                    el._updatePagination(1);

                });



            },
            /*
            @function (private) {Object} _generateSourceRowsData
            @description Searches for rows declared by the user to elaborate our data object and returns it
            */
            generateSourceRowsData: function () {

                var el = this;

                var storeData = {};
                
                var rows = el._misc.sourceFragment.querySelectorAll("vc-row");
                
                if (rows.length > 0) {

                    var columns = el.columns.replace(/\s/g, '').split(',');
                    var dataModel = {};
                    var cells;

                    // We create a data model based on the columns specified in the grid, this is done so that in case there is an entry missing one of the column values
                    // we will be able to fill it with an empty one
                    for (var i = 0; i < columns.length; i++) {
                        dataModel[columns[i]] = "";
                    }

                    // For each row we loop through its cells and fill its data object
                    for (var j = 0; j < rows.length; j++) {

                        data = Object.assign({}, dataModel);
                        data.entryid = j;

                        cells = rows[j].querySelectorAll("vc-cell");

                        for (var k = 0; k < cells.length; k++) {
                            data[cells[k].getAttribute("column")] = cells[k].innerHTML;
                        }

                        storeData[j] = data;

                    }

                }

                return storeData;

            },
            //HANDLE FUNCTIONS
            /*
            @function (private) _handleEntries
            @description Manages the redirection to another function depending on the situation
            @param {String} responseType
            @param {Boolean} cleanCurrentRange [Whether it has to clean the current page or not]
            @param {Number} start
            @param {Number} limit
            */
            handleEntries: function (responseType, cleanCurrentRange, start, limit) {

                var el = this;
                var handleFunction, dataSource, source;

                // dataSource = (el.store.type == "memory" && el._misc.pagingType != "all") ? el.store.rangeData : el.store.data;
                // source = (responseType == "object") ? dataSource.asObject() : dataSource.asArray();
                source = el.store.data;
                
                el._misc.range.start = start ? start : el._misc.range.start;
                el._misc.range.limit = limit ? limit : el._misc.range.limit;

                el._misc.range.limit = (el._misc.pagingType == "all") ? el.store.size : el._misc.range.limit;

                handleFunction = (responseType == "object") ? el._handleObjectEntries : el._handleArrayEntries;
                handleFunction.apply(el, [source, cleanCurrentRange]);

            },
            /*
            @function (private) _handleObjectEntries
            @description Handles the store data that is returned as an object
            @param {Object} storeData
            @param {Boolean} cleanCurrentRange [Whether it has to clean the current page or not]
            */
            handleObjectEntries: function (storeData, cleanCurrentRange) {

                var el = this;
                console.log('storeData', storeData);
                var columnsKeys = Object.keys(el._misc.columns);
                var rowsDocFragment = document.createDocumentFragment();
                var entriesCount = Object.keys(storeData).length;
                var dataObject;
                var row;
                var cell;
                var eventObject;

                if (cleanCurrentRange) {
                    el._refs.rowsWrapper.innerHTML = "";
                    el._resetEntriesCount();
                }

                //for each dataObject in the storeData we create a Row
                for (var key in storeData) {
                    dataObject = storeData[key];

                    row = document.createElement("vc-row");
                    row.classList.add("vc-grid-entryRow", "vc-bg1-hoverable3", "vc-bg1-border2");
                    row.dataset.entryId = dataObject[el.store.idProperty];

                    //For each column we have in the grid we will look for its value on the dataObject
                    // and create a cell, this way if a dataObject doesnt have a columnKey it will still have the cell but it will be an empty one
                    for (var i = 0; i < columnsKeys.length; i++) {

                        cell = el._createCell(columnsKeys[i], dataObject, storeData);
                        row.appendChild(cell);

                    }

                    if (el.autofit == "true" || el.autofit == true) {

                        row.classList.add("vc-grid-autofit");

                    } else {

                        row.style.minHeight = el.rowMinHeight + "px";
                    }

                    el._increaseEntriesCount();

                    rowsDocFragment.appendChild(row);

                    // Creates the callback event object for the user
                    eventObject = {

                        data: dataObject,
                        row: row

                    };

                    vcomet.triggerCallback("onRowCreated", el, el, [eventObject]);

                };

                el._refs.rowsWrapper.appendChild(rowsDocFragment);

                if (el._misc.pagingType == "auto") {
                    el._handleRowsLayout(entriesCount)
                };
            },
            /*
            @function (private) _handleArrayEntries
            @description Handles the store data that is returned as an array
            @param {Array} storeData
            @param {Boolean} cleanCurrentRange [Whether it has to clean the current page or not]
            */
            handleArrayEntries: function (storeData, cleanCurrentRange) {

                var el = this;

                var columnsKeys = Object.keys(el._misc.columns);
                var rowsDocFragment = document.createDocumentFragment();
                var entriesCount = storeData.length;
                var dataObject;
                var row;
                var cell;

                if (cleanCurrentRange) {
                    el._refs.rowsWrapper.innerHTML = "";
                }

                el._resetEntriesCount();

                //for each dataObject in the storeData we create a Row
                for (var i = 0; i < entriesCount; i++) {
                    dataObject = storeData[i];

                    row = document.createElement("vc-row");
                    row.classList.add("vc-grid-entryRow", "vc-bg1-hoverable3", "vc-bg1-border2");
                    row.dataset.entryId = dataObject[el.store.idProperty];

                    //For each column we have in the grid we will look for its value on the dataObject
                    // and create a cell, this way if a dataObject doesn't have a columnKey it will still have the cell but it will be an empty one
                    for (var j = 0; j < columnsKeys.length; j++) {

                        cell = el._createCell(columnsKeys[j], dataObject, storeData);
                        row.appendChild(cell);

                    }

                    if (el.autofit == "true" || el.autofit == true) {

                        row.classList.add("vc-grid-autofit");

                    } else {

                        row.style.minHeight = el.rowMinHeight + "px";
                    }

                    el._increaseEntriesCount();

                    rowsDocFragment.appendChild(row);
                }
                el._refs.rowsWrapper.appendChild(rowsDocFragment);

                if (el._misc.pagingType == "auto") {
                    el._handleRowsLayout(entriesCount)
                };
            },
            /*
            @function (private) _handleRowsLayout
            @description Handles everything autofit rows related, the paginations, its sizes...
            @param {Number} entriesCount
            */
            handleRowsLayout: function (entriesCount) {

                var el = this;
                var rowsCapacity = el._getRowsCapacity();

                //We will only do stuff when the rowsCapacity is bigger than one.
                //One row will be the smallest number of rows possible, we will not allow pages with no rows
                if (rowsCapacity >= 1) {

                    var existingDummiesCount = el.querySelectorAll(".vc-grid-dummyRow").length;
                    var totalPageRows = existingDummiesCount + entriesCount;
                    var dummyRowsAmount = rowsCapacity - entriesCount;

                    //If there are more rows than the capacity that we have we will remove an amount of rows
                    //until we match our capacity, the removal starts from the last one
                    if (rowsCapacity < totalPageRows) {

                        var rowsAmountDifference = totalPageRows - rowsCapacity;
                        var rows = el._refs.rowsWrapper.querySelectorAll(".vc-grid-entryRow, .vc-grid-dummyRow");
                        var rowsLength = rows.length;
                        var lastRowIndex;

                        for (var i = rowsAmountDifference; i > 0; i--) {
                            lastRowIndex = rowsLength - 1;

                            if (rows[lastRowIndex].classList.contains("vc-grid-entryRow")) {
                                el._decreaseEntriesCount();
                            }

                            el._refs.rowsWrapper.removeChild(el._refs.rowsWrapper.querySelectorAll(".vc-grid-entryRow, .vc-grid-dummyRow")[lastRowIndex]);
                            rowsLength--;
                        }

                        //If we have more capacity than actual rows displayed then we will fill the page with dummies
                    } else if (rowsCapacity > totalPageRows) {

                        var dummyDocFragment = document.createDocumentFragment();
                        var newDummiesCount = dummyRowsAmount - existingDummiesCount;
                        var dummyRow;

                        for (var i = 0; i < newDummiesCount; i++) {
                            dummyRow = document.createElement("div");
                            dummyRow.classList.add("vc-grid-autofit", "vc-grid-dummyRow");
                            dummyDocFragment.appendChild(dummyRow);
                        }

                        el._refs.rowsWrapper.appendChild(dummyDocFragment);
                    }

                    //If ourpageSize is different from the actual amount of rows we can have, we will handle
                    //different calls to reload the page with the data corresponding to the page
                    if (el.pageSize != rowsCapacity) {
                        var currentPage = parseInt(el._misc.currentPage);
                        var newPage;

                        el.pageSize = rowsCapacity;

                        newPage = currentPage > el._getStoreDataLastPage() ? el._getStoreDataLastPage() : currentPage;

                        el._selectPage(newPage);

                    }
                }
            },
            /*
            @function (private) _getStoreDataLastPage
            @description Gets the current last page depending on the store size
            */
            getStoreDataLastPage: function () {

                var el = this;

                if (el._misc.pageSizeType == "all" && typeof el.store.size == "undefined") {
                    return 1;
                }

                return Math.ceil(parseInt(el.store.size) / parseInt(el._misc.pageSize));
            },
            /*
            @function (private) _selectPage
            @description Selects a page
            @param {Number} selectedPage
            @param {Boolean} isSelected
            */
            selectPage: function (selectedPage, isSelected) {

                if (isSelected == false || isSelected == "false" || typeof isSelected == "undefined") {

                    var el = this;

                    var pageSize = parseInt(el.pageSize);
                    var rangeLimit = (parseInt(selectedPage) * pageSize);
                    var rangeStart = rangeLimit - pageSize + 1;

                    el._handleRange(rangeStart, rangeLimit, true);
                    el._updatePages(selectedPage);

                }

            },
            /*
            @function (private) _handleRange
            @description Manages the redirection to another function depending on the situation
            @param {Number} start
            @param {Number} limit
            @param {Boolean} cleanCurrentRange [Whether it has to clean the current page or not]
            */
            handleRange: function (start, limit, cleanCurrentRange) {

                var el = this;

                el._misc.range.start = start;
                el._misc.range.limit = limit;

                // el.store.read(Objeto con informacion para el rango);
                // el._handleStoreEntries(el.store.data.__sorted ? "array" : "object", cleanCurrentRange, start, limit);

            },
            /*
             @function (private) _sort
             @description Redirects the sort call depending on the situation, it also toggles the icon
             @param {Object} e [event]
             @param {Object} header
             */
            sort: function (e, header) {

                if (e.target != header.querySelector(".vc-grid-resizeIndicator")) {

                    var el = this;

                    var sortType = el._getSortTypeForHeader(header);

                    el._handleHeadersChange(header, sortType);
                    el._handleSort(header.column, sortType);

                }
            },
            /*
            @function (private) _handleSort
            @description Manages the redirection to another function depending on the situation
            @param {String} columnKey
            @param {Boolean} isDescending
            */
            handleSort: function (columnKey, sortType) {

                var el = this;

                var cleanCurrentRange = true;
                var isDescending = sortType == "descending" ? true : false;
                var dataType = sortType != "none" ? "array" : "object";

                var sortCallback = function () {
                    el._handleStoreEntries("array", cleanCurrentRange);
                };

                if (el.store.type == "rest") {

                    el.store.sortRemote(columnKey, isDescending, sortCallback);

                } else {

                    el.store.sortList(columnKey, isDescending);

                    if (el._misc.pageSizeType !== "all") {
                        // If we want the data raw, we send true as the third parameter
                        el.store.getRange(el._misc.range.start, el._misc.range.limit, sortType == "none" ? true : false);

                    }

                    // Here we call the handleStoreEntries function, after requesting sort and range
                    el._handleStoreEntries(dataType, cleanCurrentRange);

                }
            },
            /*
            @function (private) _generateSourceFragment
            @description Takes all the source declared by the user and creates its own fragment to save it
            */
            generateSourceFragment: function () {
                this._misc.sourceFragment.appendChild(this.source);
            },
            /*
            @function (private) _setDefaultStyle
            @description Check if the default element style should be applied
            */
            setDefaultStyle: function () {
                var el = this;
                // Check fill behavior
                if (vcomet.util.isTrue(el.fill)) {
                    // Content style
                    el.classList.add("vc-fill");
                }
            },
            /*
            @function (private) _updatePagination
            @description Updates pageSelectors and the navigability buttons
            @param {Number} page
            */
            updatePagination: function (page) {

                var el = this;

                el._misc.currentPage = page;

                if (el._misc.hasPagination) {

                    if (el.pagination == "strip") el._createPagesForPagesStrip();

                    el._updatePageSelector(page);
                    el._handleNavigability();

                }

            },
            /*
            @function (private) _getRowsCapacity
            @description Gets the current rows capacity
            */
            getRowsCapacity: function () {

                var el = this;
                var rowsWrapperHeight = (parseInt(el._refs.rowsWrapper.offsetHeight) == 0) ? (el.offsetHeight - (el._refs.header.offsetHeight + el._refs.footer.offsetHeight)) : el.offsetHeight;

                return Math.floor(rowsWrapperHeight / parseInt(el.rowMinHeight));
            },
            /*
            @function (private) _increaseEntriesCount
            @description Increases the entries count
            */
            increaseEntriesCount: function () {

                var el = this;

                el._misc.entriesCount++;
                el._refs.entriesCount.innerHTML = el._misc.entriesCount + " entries";
            },
            /*
            @function (private) _decreaseEntriesCount
            @description Decrease the entries count
            */
            decreaseEntriesCount: function () {

                var el = this;

                el._misc.entriesCount--;
                el._refs.entriesCount.innerHTML = el._misc.entriesCount + " entries";
            },
            /*
            @function (private) _resetEntriesCount
            @description Resets the count of the entries
            */
            resetEntriesCount: function () {

                var el = this;

                el._misc.entriesCount = 0;
                el._refs.entriesCount.innerHTML = el._misc.entriesCount + " entries";

            },
        },

        onCreated: function () {

            var el = this;

            el._setupRefs();
            el._setupMisc();

            el._generateSourceFragment();

            vcomet.createCallback("onCellCreated", el);
            vcomet.createCallback("onRowCreated", el);
            vcomet.createCallback("onEdit", el);

        },
        onInit: function () {

            var el = this;

            // ** Apply default items positioning style
            el._setDefaultStyle();

        },

        onBubbleRender: function () {

            var el = this;

            el.classList.add("vc-bg1", "vc-boxshadow1");

            el._setupPageSize();

            el._setupColumns();
            el._setupHeaders();

            el._setupContent();

        }
    });

</script>