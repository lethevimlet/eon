<template>
  <div class="vc-scroll-content"></div>
</template>

<script type="text/javascript">
  vcomet.element("vc-scroll", "vc-scroll.css", {

    privateProperties: {
      /*
      @property (private) {Array} _preventDragNodes
      @description Array containing nodes that prevent the scroll from happening
      */
      preventDragNodes: {
        value: [],
        reflect: false
      },
      /*
      @property (private) {Object} _misc
      @description Object with usefull information
      */
      misc: {
        value: {},
        reflect: false
      },
      /*
      @property (private) {Object} _refs
      @description Object with references
      */
      refs: {
        value: {},
        reflect: false
      },
    },
    properties: {
      /*
      @property {String} type
      @description Indicates the allowed scrolls, auto/horizontal/vertical
      */
      type: {
        value: "auto",
        reflect: true
      },
      /*
      @property {Number} thickness
      @description Indicates the thickness for the scroll rails
      */
      thickness: {
        value: 15,
        reflect: true
      },
      /*
      @property {Boolean} railScroll
      @description Indicates whether we want rail scrolls or not
      */
      railScrolls: {
        value: true,
        reflect: true
      },
      /*
      @property {Boolean} arrowScrolls
      @description Indicates whether we want arrow scrolls or not
      */
      arrowScrolls: {
        value: false,
        reflect: true
      },
      /*
      @property {String} static
      @description Indicates whether we want some scroll rails to be always visible or not, none/horizontal/vertical/both
      */
      static: {
        value: "none",
        reflect: true
      },
      /*
      @property {String} pushContent
      @description Indicates whether we want some scroll rails to push the content or not, none/horizontal/vertical/both
      */
      pushContent: {
        value: "none",
        reflect: true
      },
      /*
      @property {String} fit
      @description Indicates whether the scroll will autofill its container or grow according to its content until it fills its container
      */
      fit: {
        value: "false",
        reflect: true
      },
      /*
      @property {String} fillContainer
      @description Indicates whether the scroll will autofill its container or grow according to its content until it fills its container
      */
      fillContainer: {
        value: "true",
        reflect: true
      },
      /*
      @property {boolean} nativeOnDevice
      @description Whether it sould use the native scroll on devices
      */
      nativeOnDevice: {
        value: "true",
        reflect: true
      }
    },
    privateFunctions: {
      /*
      @function (private) _initMisc
      @description Initiates basic properties for the misc object
      */
      initMisc: function () {

        var el = this;

        el._misc.mouse = {};

        el._misc.vertical = {};
        el._misc.vertical.drag = {};
        el._misc.vertical.static = false;
        el._misc.vertical.position = 0;

        el._misc.horizontal = {};
        el._misc.horizontal.drag = {};
        el._misc.horizontal.static = false;
        el._misc.horizontal.position = 0;

        el._misc.square = {};
        el._misc.square.static = false;

        el._misc.arrowScroll = {};
        el._misc.arrowScroll.active = false;
        el._misc.arrowScroll.interval = {};

        el._misc.railScroll = {};
        el._misc.railScroll.active = false;
        el._misc.railScroll.interval = {};

        el._misc.dragScroll = {};
        el._misc.dragScroll.downRefreshRate = 200;
        el._misc.dragScroll.pixelRatio = window.devicePixelRatio;
        el._misc.dragScroll.inertThresholdRadius = 2 * el._misc.dragScroll.pixelRatio;
        el._misc.dragScroll.dragThresholdRadius = el._misc.dragScroll.inertThresholdRadius + (25 * el._misc.dragScroll.pixelRatio);

        el._misc.wheelScroll = {};
        el._misc.requestedScroll = {};

        el._misc.hideScrollbarsMs = 1000;

        // Threshold for the scrollbars to be shown when moving the mouse
        el._misc.moveThreshold = {};
        el._misc.moveThreshold.start = 0;
        el._misc.moveThreshold.time = 500;

        // Determines the amount of the arrow scroll
        el._misc.arrowScrollAmount = 12;

        // This helps our pointerEnter to be triggered only once
        el._misc.pointerLeft = true;

        el._misc.native = {};

        el._misc.transition = {};

        el._misc.vertical.translatePercentage = 0;
        el._misc.horizontal.translatePercentage = 0;
      },
      /*
      @function (private) _setupMisc
      @description Sets up basic properties for the misc object
      */
      setupMisc: function () {

        var el = this;

        el.arrowScrolls = (el.arrowScrolls == "true");

        el._misc.horizontal.static = el.static == "both" || el.static == "horizontal" ? true : false;
        el._misc.vertical.static = el.static == "both" || el.static == "vertical" ? true : false;

        el._misc.vertical.position = 0;
        el._misc.horizontal.position = 0;

      },
      /*
      @function (private) _setupContent
      @description Sets up basic aspects of the scroll content, such as pushing it with the scroll rails or adding the resize listener
      */
      setupContent: function () {
        this.content = this.template.querySelector(".vc-scroll-content");
      },
      /*
      @function (private) _setupResizeListeners
      @description Creates the resizeListeners for both the element and its content node
      */
      setupResizeListeners: function () {

        var el = this;

        vcomet.addResizeListener(el, "vc-scroll", function () {
          el._handleScrollResize();
        });

        vcomet.addResizeListener(el.content, "content", function () {
          el._handleScrollResize();
        });

      },
      /*
      @function (private) _setupFitSizes
      @description Assigns fit heights/widths
      */
      setupFitSizes: function () {

        var el = this;

        if (vcomet.util.isTrue(el.fit)) {

          el.style.height = "100%";
          el.style.width = "100%";

          el.content.style.height = "100%";
          el.content.style.width = "100%";

        }

      },
      /*
      @function (private) _setupContainer
      @description Sets up basic aspects of the scroll container
      */
      setupContainer: function () {

        var el = this;

        if (el.fillContainer == "true" || el.fillContainer == true) {

          el.style.height = "100%";
          el.style.width = "100%";

          el._refs.container = el.parentNode;

          el._refs.container.vcometScroll = el;
          el._refs.container.vcometScroll.content = el.content;

          if (!el._refs.container.classList.contains("vc-scroll-content")) {
            el._refs.container.classList.add("vc-scroll-container");
          }

        }

      },
      /*
      @function (private) _setupContentPush
      @description Sets up some paddings to simulate the push that native scrolls do
      */
      setupContentPush: function () {

        var el = this;

        el.content.style.paddingRight = el.pushContent == "both" || el.pushContent == "vertical" ? el.thickness + "px" : "auto";
        el.content.style.paddingBottom = el.pushContent == "both" || el.pushContent == "horizontal" ? el.thickness + "px" : "auto";

      },
      /*
      @function (private) _setupBasicEvents
      @description Sets up the basic Events
      */
      setupBasicEvents: function () {

        var el = this;

        // For desktop window we setup some events for it
        if (!vcomet.util.isTouchScreen()) {

          //This event is to show the scrolls when the mouse hovers the container
          el.addEventListener("pointerenter", function (e) {

            if (el._misc.pointerLeft) {

              if (!vcomet.util.isTrue(el._misc.horizontal.drag.active) && !vcomet.util.isTrue(el._misc.vertical.drag.active)) {
                el.showScrollbars(el._misc.hideScrollbarsMs);
              }

              el._misc.pointerLeft = false;

            }

          }, true);

          //This event is to show the scrolls when the mouse moves the container
          el.addEventListener("pointermove", function (e) {
            if (!vcomet.util.isTrue(el._misc.horizontal.drag.active) && !vcomet.util.isTrue(el._misc.vertical.drag.active)) {

              var now = Date.now();

              if ((now - el._misc.moveThreshold.start) > el._misc.moveThreshold.time) {
                el._misc.moveThreshold.start = now;
                el.showScrollbars(el._misc.hideScrollbarsMs);
              }

            }
          }, true);

          //This event is to hide the scrolls when the mouse leaves the container
          el.addEventListener("pointerleave", function (e) {
            el.hideScrollbars();
            el._misc.pointerLeft = true;
          });

        }

        // Creates the device events
        el._setupDeviceEvents();

      },
      /*
      @function (private) _setupContainerPosition
      @description Since we need our container to have a position different from static to work,
       we set relative if no position was provided to the container or its static
      */
      setupContainerPosition: function () {

        var el = this;

        if (vcomet.util.isTrue(el.fillContainer)) {
          if (window.getComputedStyle(el._refs.container, false).position == "static") {
            el._refs.container.style.position = "relative";
          }
        }

      },
      /*
      @function (private) _setupDeviceEvents
      @description Sets up the pointer events for devices
      */
      setupDeviceEvents: function () {

        var el = this;

        // We only want to setup the device setup if the user specified that it wants it that way
        if (vcomet.util.isTrue(el.nativeOnDevice)) {

          el._setupDeviceTouchAction();

          el.content.onscroll = function (e) {

            var eventObject = {};

            eventObject.trigger = "native";
            eventObject.scrollTop = el.content.scrollTop;
            eventObject.scrollLeft = el.content.scrollLeft;

            vcomet.triggerCallback("onScrolled", el, el, [eventObject]);

          };

        }

        // Enables the dragging it theres no element to prevent it
        el.content.addEventListener("pointerdown", function (e) {

          if (!vcomet.util.isTrue(el.getAttribute("native"))) {

            if (e.pointerType != "mouse") {

              el.classList.add("vc-unselectable");

              // Once the user touches the screen we set this property to true
              el._misc.dragScroll.active = true;

              // Sets the initial pointer values
              el._misc.dragScroll.initialX = e.clientX;
              el._misc.dragScroll.initialY = e.clientY;

              // Sets the current pointer values, these ones will be updated on each pointer move
              el._misc.dragScroll.currentX = e.clientX;
              el._misc.dragScroll.currentY = e.clientY;

              // InertThreshold variables declaration
              el._misc.dragScroll.inertThresholdX = e.clientX;
              el._misc.dragScroll.inertThresholdY = e.clientY;
              el._misc.dragScroll.isOnInertThreshold = true;

              // DragThreshold variables declaration
              el._misc.dragScroll.dragThresholdX = e.clientX;
              el._misc.dragScroll.dragThresholdY = e.clientY;
              el._misc.dragScroll.isOnDragThreshold = true;

              // Timestamp of the moment the user started the scroll
              el._misc.dragScroll.timeStamp = +new Date();

              // If there is a deceleration animation frame going on it will cancel it"
              window.cancelAnimationFrame(el._misc.dragScroll.easeAnimationFrame);

            }

          }

        }, false);

        // Handles the dragScroll
        el.content.addEventListener("pointerleave", function (e) {
          el._misc.dragScroll.active = false;
        });

        el.content.addEventListener("pointermove", function (e) {

          // Only do things when the user has clicked to drag
          if (el._misc.dragScroll.active) {

            el.classList.remove("active-transitions");

            el._restartOrigin(e);
            el._handleDirection(e);
            el._handleInertThreshold(e);
            el._handleDragThreshold(e);

            var hasMoved = Math.round(el._misc.dragScroll.currentY) != Math.round(e.clientY) || Math.round(el._misc.dragScroll.currentX) != Math.round(e.clientX);

            // If the pointer is active , has moved and the user is not on the inertThreshold
            if (hasMoved && !el._misc.dragScroll.isOnInertThreshold) {

              // Drag treshold monitor for each axis
              el._handleDrag(e);

              e.preventDefault();
              e.stopPropagation();

            }

          }

        }, false);

        // Finishes the dragging when releasing
        el.content.addEventListener("pointerup", function (e) {

          if (el._misc.dragScroll.active && !el._misc.dragScroll.isOnDragThreshold) {

            var timeStampDiff = +new Date() - el._misc.dragScroll.timeStamp;

            var verticalDiff = el._misc.dragScroll.initialY - e.clientY;
            var horizontalDiff = el._misc.dragScroll.initialX - e.clientX;

            var advanceConstant = 800;
            var durationConstant = 1600;
            var durationMultiplier = 1000;
            var speed = Math.abs(verticalDiff) > Math.abs(horizontalDiff) ? Math.abs(verticalDiff) / timeStampDiff : Math.abs(horizontalDiff) / timeStampDiff;

            var vRatio, hRatio, higherRatio, vAdvance, hAdvance, vEnd, hEnd;

            e.stopPropagation();

            // Here we find out the amount of scroll that has been done in positive values
            verticalDiff = verticalDiff < 0 ? verticalDiff * -1 : verticalDiff;
            horizontalDiff = horizontalDiff < 0 ? horizontalDiff * -1 : horizontalDiff;

            // Here we calculate how much the content will be scrolled
            timeStampDiff = timeStampDiff == 0 ? 1 : timeStampDiff;

            vRatio = (verticalDiff / el.offsetHeight);
            hRatio = (horizontalDiff / el.offsetWidth);

            higherRatio = Math.abs(vRatio) > Math.abs(hRatio) ? vRatio : hRatio;

            vAdvance = (el.offsetHeight * vRatio) * advanceConstant * speed;
            hAdvance = (el.offsetWidth * hRatio) * advanceConstant * speed;

            vAdvance = el._misc.dragScroll.verticalDirection == "up" ? vAdvance : vAdvance * -1;
            hAdvance = el._misc.dragScroll.horizontalDirection == "left" ? hAdvance : hAdvance * -1;

            vEnd = (el._misc.dragScroll.initialY + vAdvance) / timeStampDiff;
            hEnd = (el._misc.dragScroll.initialX + hAdvance) / timeStampDiff;

            if (higherRatio !== 0) {

              var keepGoing = false;
              var duration = durationConstant + (durationMultiplier * higherRatio * speed);
              var endTime = +new Date() + duration;

              el.showScrollbars(el._misc.hideScrollbarsMs);

              // This is set so that when looping we now where we started
              el._misc.dragScroll.initialX = el._misc.horizontal.position;
              el._misc.dragScroll.initialY = el._misc.vertical.position;

              // Function that is iterated when requesting animation frame
              easeAnimation = function () {

                // Get animation progress
                var currentTime = +new Date();
                var remaining = (endTime - currentTime);
                var rate = remaining / duration;

                // This makes the reate to change in an EASE way
                rate = 1 - Math.pow(rate, 3);

                // Do some animation
                keepGoing = el._handleEaseAnimation(rate, vEnd, hEnd);

                if (keepGoing) {
                  el._misc.dragScroll.easeAnimationFrame = window.requestAnimationFrame(easeAnimation);
                } else {
                  el.hideScrollbars(200);
                }

              };

              easeAnimation();

            }

          }

          el._misc.dragScroll.active = false;

        });

      },
      /*
      @function (private) _setupScrollbars
      @description Manages the first call to the scrollbar setups
      */
      setupScrollBars: function () {

        var el = this;

        var hasVerticalScroll = ((el.content.scrollHeight > el.offsetHeight) || el._misc.vertical.static == true);
        var hasHorizontalScroll = ((el.content.scrollWidth > el.offsetWidth) || el._misc.horizontal.static == true);

        if ((hasVerticalScroll && el._isAllowedToHaveScroll("vertical")) && (hasHorizontalScroll && el._isAllowedToHaveScroll("horizontal"))) {
          el._setupSquare();
        }

        if (hasVerticalScroll && el._isAllowedToHaveScroll("vertical")) {
          el._setupVerticalScroll();
        }

        if (hasHorizontalScroll && el._isAllowedToHaveScroll("horizontal")) {
          el._setupHorizontalScroll();
        }

        //This listener handles the arrow scroll stopping if theres and actual arrowScroll being made
        document.addEventListener("pointerup", function () {
          el._handleArrowScrollStop();
          el._handleRailScrollStop();
        });

      },
      /*
      @function (private) _setupVerticalScroll
      @description Sets up the vertical scroll
      */
      setupVerticalScroll: function () {

        var el = this;
        var delay = 30;
        var throttle;

        if (!el._misc.vertical.created) {

          el._createVerticalScroll();

          //Here we use the computed style of the rail to get a more exact value of its height, we were using
          //offsetHeight before but it was returning a rounded integer, that caused missmatches when creating the bar height
          el._refs.verticalBar.style.transform = "translate3d(0, 0, 0)";
          el._refs.verticalBar.style.height = Math.ceil(parseFloat(el._refs.verticalRail.offsetHeight / (el.content.scrollHeight / el.offsetHeight))) + "px";

          //When left clicking on the scrollBar we will start the dragging event
          el._refs.verticalBar.addEventListener("pointerdown", function (e) {
            if (e.button == 0) {
              e.preventDefault();
              e.stopPropagation();
              el._misc.vertical.drag.active = true;
              el._misc.vertical.drag.start = e.clientY - el._refs.verticalBar.getBoundingClientRect().top;
            }
          });

          //When the drag event is active and we start moving the mouse we will scroll the content and the bar
          document.addEventListener("pointermove", function (e) {

            el._misc.mouse.clientY = e.clientY;

            if (el._misc.vertical.drag.active == "true" || el._misc.vertical.drag.active == true) {
              el._handleVerticalDrag(e.clientY);
            }
          });

          //When releasing the mouse button we set the dragging event bool to false
          document.addEventListener("pointerup", function (e) {
            var rect = el.getBoundingClientRect();
            if (!(e.clientX > rect.left && e.clientX < rect.right && e.clientY > rect.top && e.clientY < rect.bottom) && el._misc.vertical.drag.active == true) {
              el.hideScrollbars();
            }
            el._misc.vertical.drag.active = false;
          });

          //This event is exclusive for the vertical scroll, it handles the mousewheel to scroll the content
          el.addEventListener("wheel", function (e) {

            if (!throttle) {

              throttle = true;

              if (el._misc.vertical.created) {

                // We only want to do things if the native scroll its not being used
                if (!vcomet.util.isTrue(el.getAttribute("native"))) {

                  e.preventDefault();

                  // Handle the scroll if the mouse is not in an element that prevents it
                  if (el._refs.verticalScroll.classList.contains("vc-scroll-active")) {

                    var preventDragScroll = false;

                    for (var i = 0; i < el._preventDragNodes.length; i++) {
                      if (el._preventDragNodes[i].isOnPath == true) {
                        preventDragScroll = true;
                        break;
                      }
                    }

                    if (!preventDragScroll) {
                      el._handleWheelScroll(e);
                    }

                  }

                }

              }

              setTimeout(function () {
                throttle = false;
              }, delay);

            }

          });

          el._refs.verticalRail.addEventListener("pointerdown", function (e) {

            if (el.railScrolls === true || el.railScrolls == "true") {

              el.classList.add("active-transitions");

              var railScrollFunction = function () {

                var railTop = el._refs.verticalRail.getBoundingClientRect().top;
                var railHeight = el._refs.verticalRail.getBoundingClientRect().height;

                var barTop = el._refs.verticalBar.getBoundingClientRect().top;
                var barHeight = el._refs.verticalBar.getBoundingClientRect().height;

                var isMeantToScrollUp = (railTop < e.clientY && e.clientY < barTop);
                var isMeantToScrollDown = ((railTop + railHeight) > e.clientY && (barTop + barHeight) < e.clientY);

                var scrollAmount = el.content.scrollHeight * (barHeight / railHeight);
                var currentVerticalPosition = el._misc.vertical.position;
                var limit = el._getVerticalScrollLimit();

                var shouldStop = parseFloat(barTop) + barHeight > e.clientY && e.clientY > parseFloat(barTop);

                if (shouldStop) {

                  el._handleRailScrollStop();

                } else {

                  var scrollUpPosition = currentVerticalPosition + scrollAmount < 0 ? currentVerticalPosition + scrollAmount : 0;
                  var scrollDownPosition = currentVerticalPosition - scrollAmount > limit ? currentVerticalPosition - scrollAmount : limit;
                  var verticalPosition = isMeantToScrollUp ? scrollUpPosition : scrollDownPosition;

                  //If the scroll has changed we trigger the callback
                  if (currentVerticalPosition != verticalPosition) {
                    el._animateScroll({ horizontal: el._misc.horizontal.position, vertical: verticalPosition, trigger: "rail" });
                  }

                }

              };

              //Here we create the interval to scroll
              el._misc.railScroll.active = true;
              el._misc.railScroll.interval = setInterval(function () {
                if (el._misc.vertical.drag.active != true) {
                  railScrollFunction();
                }
              }, 100);

            }

          });

          el._misc.vertical.created = true;

          vcomet.triggerCallback("onVerticalScrollCreated", el, el, [el._refs.verticalScroll]);
        }

      },
      /*
      @function (private) _setupHorizontalScroll
      @description Sets up the horizontal scroll
      */
      setupHorizontalScroll: function () {

        var el = this;

        if (!el._misc.horizontal.created) {

          el._createHorizontalScroll();

          //Here we use the computed style of the rail to get a more exact value of its width, we were using
          //offsetWidth before but it was returning a rounded integer, that caused missmatches when creating the bar width
          el._refs.horizontalBar.style.transform = "translate3d(0, 0, 0)";
          el._refs.horizontalBar.style.width = Math.ceil(parseFloat(window.getComputedStyle(el._refs.horizontalRail, null).getPropertyValue("width").split("px")[0] / (el.content.scrollWidth / el.offsetWidth))) + "px";

          //When left clicking on the scrollBar we will start the dragging event
          el._refs.horizontalBar.addEventListener("pointerdown", function (e) {
            if (e.button == 0) {
              e.preventDefault();
              e.stopPropagation();
              el._misc.horizontal.drag.active = true;
              el._misc.horizontal.drag.start = e.clientX - el._refs.horizontalBar.getBoundingClientRect().left;
            }
          });

          //When the drag event is active and we start moving the mouse we will scroll the content and the bar
          document.addEventListener("pointermove", function (e) {
            el._misc.mouse.clientX = e.clientX;

            if (el._misc.horizontal.drag.active == "true" || el._misc.horizontal.drag.active == true) {
              el._handleHorizontalDrag(e);
            }
          });

          //When releasing the mouse button we set the dragging event bool to false
          document.addEventListener("pointerup", function (e) {
            var rect = el.getBoundingClientRect();
            if (!(e.clientX > rect.left && e.clientX < rect.right && e.clientY > rect.top && e.clientY < rect.bottom) && el._misc.horizontal.drag.active == true) {
              el.hideScrollbars();
            }
            el._misc.horizontal.drag.active = false;
          });

          el._refs.horizontalRail.addEventListener("pointerdown", function (e) {

            if (el.railScrolls === true || el.railScrolls == "true") {

              el.classList.add("active-transitions");

              var railScrollFunction = function () {

                var railLeft = el._refs.horizontalRail.getBoundingClientRect().left;
                var railWidth = el._refs.horizontalRail.getBoundingClientRect().width;

                var barLeft = el._refs.horizontalBar.getBoundingClientRect().left;
                var barWidth = el._refs.horizontalBar.getBoundingClientRect().width;

                var isMeantToScrollLeft = (railLeft < e.clientX && e.clientX < barLeft);
                var isMeantToScrollRight = ((railLeft + railWidth) > e.clientX && (barLeft + barWidth) < e.clientX);

                var scrollAmount = el.content.scrollWidth * (barWidth / railWidth);
                var currentHorizontalPosition = el._misc.horizontal.position;
                var limit = el._getHorizontalScrollLimit();

                var shouldStop = parseFloat(barLeft) + barWidth > e.clientX && e.clientX > parseFloat(barLeft);

                if (shouldStop) {

                  el._handleRailScrollStop();

                } else {

                  var horizontalPosition = isMeantToScrollLeft ? currentHorizontalPosition + scrollAmount < 0 ? currentHorizontalPosition + scrollAmount : 0 : currentHorizontalPosition - scrollAmount > limit ? currentHorizontalPosition - scrollAmount : limit;

                  //If the scroll has changed we trigger the callback
                  if (currentHorizontalPosition != horizontalPosition) {
                    el._animateScroll({ horizontal: horizontalPosition, vertical: el._misc.vertical.position, trigger: "rail" });
                  };

                }

              };

              //Here we create the interval to scroll
              el._misc.railScroll.active = true;
              el._misc.railScroll.interval = setInterval(function () {
                if (el._misc.horizontal.drag.active != true) {
                  railScrollFunction();
                }
              }, 100);

            }

          });

          el._misc.horizontal.created = true;

          vcomet.triggerCallback("onHorizontalScrollCreated", el, el, [el._refs.horizontalScroll]);
        }

      },
      /*
      @function (private) _setupSquare
      @description Sets up the square separating both scrolls
      */
      setupSquare: function () {

        var el = this;
        var square = document.createElement("div");

        //If ether the horizontal or the vertical scroll are static we will make the square static aswell
        if (el._misc.horizontal.static == true || el._misc.vertical.static == true) {
          square.classList.add("vc-scroll-static");
          el._misc.square.static = true;
        }

        square.classList.add("vc-scroll-square");
        square.classList.add("vc-bg1");
        square.classList.add("vc-scroll-active");

        //The square width and height depends on the vertical and horizontal scroll thickness
        square.style.height = el.thickness + "px";
        square.style.width = el.thickness + "px";

        el._refs.square = square;
        el.appendChild(square);

        el._misc.square.created = true;
      },
      /*
      @function (private) _setupDeviceTouchAction
      @description function_description
      @param {param_type} param_name [param_description]
      */
      setupDeviceTouchAction: function () {

        var el = this;

        if (vcomet.util.isTrue(el.nativeOnDevice)) {

          if (vcomet.util.isTouchScreen()) {

            el._performScroll(0, 0);

            el.removeAttribute("touch-action");
            el.setAttribute("native", "true");

            el.content.scrollTop = Math.abs(el._misc.vertical.position);
            el.content.scrollLeft = Math.abs(el._misc.horizontal.position);

          } else {

            el.setAttribute("touch-action", "none");
            el.removeAttribute("native");

            if (el._misc.vertical.created == true) {
              el._verticalUpdate(-el.content.scrollTop);
            }

            if (el._misc.horizontal.created == true) {
              el._horizontalUpdate(-el.content.scrollLeft);
            }

          }


        }

      },
      /*
      @function (private) _definePublicScrollProperties
      @description Creates definitions for scrollTop/scrollLeft properties
      */
      definePublicScrollProperties: function () {

        var el = this;
        var scrollTopDescriptor = {};
        var scrollLeftDescriptor = {};

        // ScrollTop property descriptor
        scrollTopDescriptor.get = function () {
          return Math.abs(el._misc.vertical.position);
        };

        scrollTopDescriptor.set = function (value) {

          var transition = false;
          var verticalPosition;

          if (value.constructor === Array) {
            verticalPosition = value[0];
            transition = value[1];
          } else {
            verticalPosition = value;
          }

          el.scrollTo(verticalPosition, Math.abs(el._misc.horizontal.position), transition);

        };

        // ScrollLeft property descriptor
        scrollLeftDescriptor.get = function () {
          return Math.abs(el._misc.horizontal.position);
        };

        scrollLeftDescriptor.set = function (value) {

          var transition = false;
          var horizontalPosition;

          if (value.constructor === Array) {
            horizontalPosition = value[0];
            transition = value[1];
          } else {
            horizontalPosition = value;
          }

          el.scrollTo(Math.abs(el._misc.vertical.position), horizontalPosition, transition);

        };

        // Defines scrollTop, scrollLeft properties to trigger our functions
        Object.defineProperty(el, "scrollTop", scrollTopDescriptor);
        Object.defineProperty(el, "scrollLeft", scrollLeftDescriptor);

      },
      /*
      @function (private) _setupFragmentForSourceNodes
      @description Reads all the source nodes and appends them to a fragment
      */
      moveSourceToContent: function () {

        var sourceNodes = this.getSourceElements();
        var content = this.template.querySelector(".vc-scroll-content");

        for (var i = 0; i < sourceNodes.length; i++) {
          content.appendChild(sourceNodes[i]);
        }

      },
      /*
      @function (private) _restartOrigin
      @description Restarts the origin point from which we will base our drag up calculations
      @param {Object} e [Event]
      */
      restartOrigin: function (e) {

        var el = this;
        var currentTimestamp = +new Date();

        // If when moved the user has exceeded the established amount of time for him to release we refresh all the values as if starting again the scroll
        if ((currentTimestamp - el._misc.dragScroll.timeStamp) > el._misc.dragScroll.downRefreshRate) {

          // Sets the initial pointer values
          el._misc.dragScroll.initialX = e.clientX;
          el._misc.dragScroll.initialY = e.clientY;

          // Sets the current pointer values, these ones will be updated on each pointer move
          el._misc.dragScroll.currentX = e.clientX;
          el._misc.dragScroll.currentY = e.clientY;

          // DragThreshold variables declaration
          el._misc.dragScroll.dragThresholdX = e.clientX;
          el._misc.dragScroll.dragThresholdY = e.clientY;
          el._misc.dragScroll.isOnDragThreshold = true;

          // Timestamp of the moment the user started the scroll
          el._misc.dragScroll.timeStamp = currentTimestamp;

        }

      },
      /*
      @function (private) _handleScrollToRequest
      @description Handles the scroll to request
      @param {Number} verticalPosition
      @param {Number} horizontalPosition
      @param {Boolean} transition [Whether the user wants a transition while scrolling to the request position]
      */
      handleScrollToRequest: function (verticalPosition, horizontalPosition, transition) {
        
        var el = this;

        verticalPosition = verticalPosition ? verticalPosition : el._misc.vertical.position;
        horizontalPosition = horizontalPosition ? horizontalPosition : el._misc.horizontal.position;

        el._verticalUpdate(-Math.abs(verticalPosition));
        el._horizontalUpdate(-Math.abs(horizontalPosition));

        // It adds it back if the user requested so and prepares what we need to call the "onScrolled" callback for every animationFrame
        if (transition) {

          el._animateScroll({ vertical: el._misc.vertical.position, horizontal:  el._misc.horizontal.position, trigger: "requested" });

        } else {

          el.classList.remove("active-transitions");
          el._performScroll(el._misc.horizontal.position, el._misc.vertical.position);
          vcomet.triggerCallback("onScrolled", el, el, [el._createScrollEventObject("requested")]);

        }

      },
      /*
      @function (private) _handleNativeScrollToRequest
      @description Handles the scroll to request for the native situation
      @param {Number} verticalPosition
      @param {Number} horizontalPosition
      @param {Boolean} transition [Whether the user wants a transition while scrolling to the request position]
      */
      handleNativeScrollToRequest: function (verticalPosition, horizontalPosition, transition) {

        var el = this;

        if (!transition) {

          el.content.scrollTop = verticalPosition;
          el.content.scrollLeft = horizontalPosition;

          el._verticalUpdate(-el.content.scrollTop);
          el._horizontalUpdate(-el.content.scrollLeft);

        } else {

          var keepGoing = false;
          var duration = 400;
          var endTime = +new Date() + duration;

          var vEnd = verticalPosition > el.content.scrollHeight ? el.content.scrollHeight : verticalPosition;
          var hEnd = verticalPosition > el.content.scrollWidth ? el.content.scrollWidth : horizontalPosition;

          var vAmount = verticalPosition - el.content.scrollTop;
          var hAmount = horizontalPosition - el.content.scrollLeft;

          el._verticalUpdate(-vEnd);
          el._horizontalUpdate(-hEnd);

          el._misc.native.initialY = el.content.scrollTop;
          el._misc.native.initialX = el.content.scrollLeft;

          var easeScrollAnimation = function () {

            // Get animation progress
            var currentTime = +new Date();
            var remaining = (endTime - currentTime);
            var rate = remaining / duration;

            // This makes the reate to change in an EASE way
            rate = 1 - Math.pow(rate, 3);

            // Do some animation
            keepGoing = el._handleNativeEaseAnimation(rate, vAmount, hAmount);

            if (keepGoing) {
              el._misc.native.easeAnimationFrame = window.requestAnimationFrame(easeScrollAnimation);
            }

          };

          easeScrollAnimation();

        }

      },
      /*
      @function (private) _handleInertThreshold
      @description Handles whether the user has left the inert threshold
      @param {Object} e [Event]
      */
      handleInertThreshold: function (e) {

        var el = this;

        var pointToinertThresholdY = el._misc.dragScroll.inertThresholdY > e.clientY ? el._misc.dragScroll.inertThresholdY - e.clientY : e.clientY - el._misc.dragScroll.inertThresholdY;
        var pointToinertThresholdX = el._misc.dragScroll.inertThresholdX > e.clientX ? el._misc.dragScroll.inertThresholdX - e.clientX : e.clientX - el._misc.dragScroll.inertThresholdX;

        if ((pointToinertThresholdY > el._misc.dragScroll.inertThresholdRadius || pointToinertThresholdX > el._misc.dragScroll.inertThresholdRadius) && el._misc.dragScroll.isOnInertThreshold == true) {

          pointToinertThresholdY = el._misc.dragScroll.verticalDirection == "up" ? pointToinertThresholdY : pointToinertThresholdY * -1;
          pointToinertThresholdX = el._misc.dragScroll.horizontalDirection == "left" ? pointToinertThresholdX : pointToinertThresholdX * -1;

          el._misc.dragScroll.currentY = el._misc.dragScroll.currentY + pointToinertThresholdY;
          el._misc.dragScroll.currentX = el._misc.dragScroll.currentX + pointToinertThresholdX;

          el._misc.dragScroll.isOnInertThreshold = false;

        }

      },
      /*
      @function (private) _handleDragThreshold
      @description Handles whether the user has left the drag threshold
      @param {Object} e [Event]
      */
      handleDragThreshold: function (e) {

        var el = this;

        var pointToDragThresholdY = el._misc.dragScroll.dragThresholdY > e.clientY ? el._misc.dragScroll.dragThresholdY - e.clientY : e.clientY - el._misc.dragScroll.dragThresholdY;
        var pointToDragThresholdX = el._misc.dragScroll.dragThresholdX > e.clientX ? el._misc.dragScroll.dragThresholdX - e.clientX : e.clientX - el._misc.dragScroll.dragThresholdX;

        if ((pointToDragThresholdY > el._misc.dragScroll.dragThresholdRadius || pointToDragThresholdX > el._misc.dragScroll.dragThresholdRadius) && el._misc.dragScroll.isOnDragThreshold == true) {

          pointToDragThresholdY = el._misc.dragScroll.verticalDirection == "up" ? pointToDragThresholdY : pointToDragThresholdY * -1;
          pointToDragThresholdX = el._misc.dragScroll.horizontalDirection == "left" ? pointToDragThresholdX : pointToDragThresholdX * -1;

          el._misc.dragScroll.currentY = e.clientY;
          el._misc.dragScroll.currentX = e.clientX;

          el._misc.dragScroll.isOnDragThreshold = false;

        }

      },
      /*
      @function (private) _handleDrag
      @description Handles the scrolling when dragging
      @param {Object} e [Event]
      */
      handleDrag: function (e) {

        var el = this;

        el._misc.direction = undefined;

        var verticalScrollPosition, horizontalScrollPosition;

        if (e.clientY != el._misc.dragScroll.currentY && el._misc.vertical.created) {

          verticalScrollPosition = el._getVerticalScrollPosition(e);
          el._verticalUpdate(verticalScrollPosition);

          el._misc.direction = "vertical";

        }

        if (e.clientX != el._misc.dragScroll.currentX && el._misc.horizontal.created) {

          horizontalScrollPosition = el._getHorizontalScrollPosition(e);
          el._horizontalUpdate(horizontalScrollPosition);

        }

        el.showScrollbars();

        el._performScroll(el._misc.horizontal.position, el._misc.vertical.position);

        el._misc.dragScroll.currentX = e.clientX;
        el._misc.dragScroll.currentY = e.clientY;

        //Trigger the scroll event
        if (el._misc.direction) {
          var eventObject = el._createScrollEventObject("drag");
          vcomet.triggerCallback("onScrolled", el, el, [eventObject]);
        }

      },
      /*
      @function (private) _handleDirection
      @description Handles and updates the current direction of the scroll
      @param {Object} e [Event]
      */
      handleDirection: function (e) {

        var el = this;

        var newVerticalDirection = e.clientY > el._misc.dragScroll.currentY ? "up" : "down";
        var newHorizontalDirection = e.clientX > el._misc.dragScroll.currentX ? "left" : "right";

        el._misc.dragScroll.verticalDirection = e.clientY > el._misc.dragScroll.initialY ? "up" : "down";
        el._misc.dragScroll.horizontalDirection = e.clientX > el._misc.dragScroll.initialX ? "left" : "right";

      },
      /*
      @function (private) {Number} _getHorizontalScrollPosition
      @description Returns the horizontal scroll position
      @param {Object} e [Event]
      */
      getHorizontalScrollPosition: function (e) {

        var el = this;

        var horizontalScrollAmount = e.clientX - el._misc.dragScroll.currentX;
        var horizontalScrollPosition = el._misc.horizontal.position + horizontalScrollAmount;

        horizontalScrollPosition = horizontalScrollPosition > 0 ? 0 : horizontalScrollPosition;
        horizontalScrollPosition = horizontalScrollPosition + el.content.scrollWidth < el.offsetWidth ? el.offsetWidth - el.content.scrollWidth : horizontalScrollPosition;

        return horizontalScrollPosition;

      },
      /*
      @function (private) {Number} _getVerticalScrollPosition
      @description Returns the vertical scroll position
      @param {Object} e [Event]
      */
      getVerticalScrollPosition: function (e) {

        var el = this;

        var verticalScrollAmount = el._misc.dragScroll.currentY - e.clientY;
        var verticalScrollPosition = el._misc.vertical.position - verticalScrollAmount;

        verticalScrollPosition = verticalScrollPosition > 0 ? 0 : verticalScrollPosition;
        verticalScrollPosition = verticalScrollPosition + el.content.scrollHeight < el.offsetHeight ? el.offsetHeight - el.content.scrollHeight : verticalScrollPosition;

        return verticalScrollPosition;

      },
      /*
      @function (private) _handleArrowScroll
      @description Handles the scrolling of the arrow
      @param {Object} e [Event]
      @param {Object} el
      @param {Object} arrowButton
      */
      handleArrowScroll: function (e, el, arrowButton) {

        el.classList.add("active-transitions");

        //We trigger the scrolls when the mouse button trigger is the left one
        if (e.button == 0) {

          var scrollFunction;

          if (arrowButton.dataset.direction == "up") {

            scrollFunction = function () {

              var currentVerticalPosition = el._misc.vertical.position;

              el._misc.vertical.position = currentVerticalPosition + el._misc.arrowScrollAmount < 0 ? currentVerticalPosition + el._misc.arrowScrollAmount : 0;

              el._verticalUpdate(el._misc.vertical.position);
              el._performScroll(el._misc.horizontal.position, el._misc.vertical.position);
              el.showScrollbars(el._misc.hideScrollbarsMs);

              //If the scroll has changed we trigger the callback
              if (currentVerticalPosition != el._misc.vertical.position) {
                var eventObject = el._createScrollEventObject("arrow");
                vcomet.triggerCallback("onScrolled", el, el, [eventObject]);
              }
            };

          } else if (arrowButton.dataset.direction == "down") {

            scrollFunction = function () {

              var currentVerticalPosition = el._misc.vertical.position;
              var limit = el._getVerticalScrollLimit();

              el._misc.vertical.position = currentVerticalPosition - el._misc.arrowScrollAmount > limit ? currentVerticalPosition - el._misc.arrowScrollAmount : limit;

              el._verticalUpdate(el._misc.vertical.position);
              el._performScroll(el._misc.horizontal.position, el._misc.vertical.position);
              el.showScrollbars(el._misc.hideScrollbarsMs);

              ///If the scroll has changed we trigger the callback
              if (currentVerticalPosition != el._misc.vertical.position) {
                var eventObject = el._createScrollEventObject("arrow");
                vcomet.triggerCallback("onScrolled", el, el, [eventObject]);
              }
            };

          } else if (arrowButton.dataset.direction == "left") {

            scrollFunction = function () {

              var currentHorizontalPosition = el._misc.horizontal.position;

              el._horizontalUpdate(currentHorizontalPosition + el._misc.arrowScrollAmount < 0 ? currentHorizontalPosition + el._misc.arrowScrollAmount : 0);
              el._performScroll(el._misc.horizontal.position, el._misc.vertical.position);
              el.showScrollbars(el._misc.hideScrollbarsMs);

              //If the scroll has changed we trigger the callback
              if (currentHorizontalPosition != el._misc.horizontal.position) {
                var eventObject = el._createScrollEventObject("arrow");
                vcomet.triggerCallback("onScrolled", el, el, [eventObject]);
              }
            };

          } else if (arrowButton.dataset.direction == "right") {

            scrollFunction = function () {

              var currentHorizontalPosition = el._misc.horizontal.position;
              var limit = el._getHorizontalScrollLimit();

              el._horizontalUpdate(currentHorizontalPosition - el._misc.arrowScrollAmount > limit ? currentHorizontalPosition - el._misc.arrowScrollAmount : limit);
              el._performScroll(el._misc.horizontal.position, el._misc.vertical.position);
              el.showScrollbars(el._misc.hideScrollbarsMs);

              //If the scroll has changed we trigger the callback
              if (currentHorizontalPosition != el._misc.horizontal.position) {
                var eventObject = el._createScrollEventObject("arrow");
                vcomet.triggerCallback("onScrolled", el, el, [eventObject]);
              }
            };

          }

          //Here we create the interval to scroll
          el._misc.arrowScroll.active = true;
          el._misc.arrowScroll.interval = setInterval(function () {
            scrollFunction();
          }, 50);

        }
      },
      /*
      @function (private) _handleEaseAnimation
      @description Eases the drag-release animation
      @param {Number} rate
      @param {Number} verticalAmount
      @param {Number} horizontalAmount
      */
      handleEaseAnimation: function (rate, verticalAmount, horizontalAmount) {

        var el = this;

        if (rate >= 1) {

          // If it surpasses 1 then it means we are done and we can cancel the animation frame and set the timout to hide the scrolls
          window.cancelAnimationFrame(el._misc.dragScroll.easeAnimationFrame);
          el.hideScrollbars(200);
          return false;

        } else {

          var translateH, translateV, verticalScrollPosition, horizontalScrollPosition, eventObject;

          el._misc.direction = undefined;

          // Here we calculate the transation to be done in this iteration based on the rate and the final amount
          translateV = rate * verticalAmount;
          translateH = rate * horizontalAmount;

          verticalScrollPosition = parseInt(el._misc.dragScroll.initialY) + parseInt(translateV);
          horizontalScrollPosition = parseInt(el._misc.dragScroll.initialX) + parseInt(translateH);

          // Here we check if the remaining amount exceeds the limits
          verticalScrollPosition = verticalScrollPosition > 0 ? 0 : verticalScrollPosition;
          verticalScrollPosition = verticalScrollPosition + el.content.scrollHeight < el.offsetHeight ? el.offsetHeight - el.content.scrollHeight : verticalScrollPosition;

          horizontalScrollPosition = horizontalScrollPosition > 0 ? 0 : horizontalScrollPosition;
          horizontalScrollPosition = horizontalScrollPosition + el.content.scrollWidth < el.offsetWidth ? el.offsetWidth - el.content.scrollWidth : horizontalScrollPosition;

          // Check if it changed, to determine the scroll event direction
          if (el._misc.vertical.position != verticalScrollPosition) {
            el._misc.direction = "vertical";
          }

          if (el._misc.horizontal.position != horizontalScrollPosition) {
            el._misc.direction = el._misc.direction == "vertical" ? "both" : "horizontal";
          }

          // Update the transform values
          el._verticalUpdate(verticalScrollPosition);
          el._horizontalUpdate(horizontalScrollPosition);

          el._performScroll(el._misc.horizontal.position, el._misc.vertical.position);

          if (el._misc.direction) {
            eventObject = el._createScrollEventObject("drag");
            vcomet.triggerCallback("onScrolled", el, el, [eventObject]);
          }

          return true;

        }

      },
      /*
      @function (private) _handleEaseAnimation
      @description Eases the drag-release animation
      @param {Number} rate
      @param {Number} verticalAmount
      @param {Number} horizontalAmount
      */
      handleNativeEaseAnimation: function (rate, verticalAmount, horizontalAmount) {

        var el = this;

        if (rate >= 1) {

          // If it surpasses 1 then it means we are done and we can cancel the animation frame and set the timout to hide the scrolls
          window.cancelAnimationFrame(el._misc.native.easeAnimationFrame);
          return false;

        } else {

          var translateH, translateV, verticalScrollPosition, horizontalScrollPosition, eventObject;

          // Here we calculate the transation to be done in this iteration based on the rate and the final amount
          translateV = rate * verticalAmount;
          translateH = rate * horizontalAmount;

          el.content.scrollTop = el._misc.native.initialY + translateV;
          el.content.scrollLeft = el._misc.native.initialX + translateH;

          return true;

        }

      },
      /*
      @function (private) _handleArrowScrollStop
      @description Handles the mouseup event when the user is scrolling with the arrows and clears the interval
      */
      handleArrowScrollStop: function () {
        var el = this;
        if (el._misc.arrowScroll.active == true) {
          clearInterval(el._misc.arrowScroll.interval);
          el._misc.arrowScroll.active = false;
        }
      },
      /*
      @function (private) _handleRailScrollStop
      @description Handles the mouseup event when the user is scrolling while clicking on the rail and clears the interval
      */
      handleRailScrollStop: function () {
        var el = this;
        if (el._misc.railScroll.active == true) {
          clearInterval(el._misc.railScroll.interval);
          el._misc.railScroll.active = false;
        }
      },
      /*
      @function (private) _handleScrollResize
      @description Handles the scroll resizes when the contents size has changed
      */
      handleScrollResize: function () {

        var el = this;

        if (!vcomet.util.isTrue(el.getAttribute("native"))) {

          var hasSquare = (el._misc.square.created == true);
          var hasHorizontalScroll = (el.content.scrollWidth > el.offsetWidth);
          var hasVerticalScroll = (el.content.scrollHeight > el.offsetHeight);

          //If we have horizontal and vertical scroll but we set the square to active
          if ((hasHorizontalScroll && el._isAllowedToHaveScroll("horizontal")) && (hasVerticalScroll && el._isAllowedToHaveScroll("vertical"))) {

            //If we dont have it we create it
            if (!hasSquare) {
              el._setupSquare();
            }

            el._refs.square.classList.add("vc-scroll-active");
            hasSquare = true;
          }

          if (el._isAllowedToHaveScroll("vertical")) {

            //If the scroll is already created we just check if the square is active, if it is then we
            //change the scroll height to give the square the space it needs; else just give it 100%
            if (el._misc.vertical.created == true) {

              //If we have verticalScroll
              if (hasVerticalScroll || (!hasVerticalScroll && el._misc.vertical.translatePercentage != 0)) {
                
                var scrollLimit = el._getVerticalScrollLimit();
                var proportionalTranslatePosition = (scrollLimit * el._misc.vertical.translatePercentage) / 100;

                proportionalTranslatePosition = proportionalTranslatePosition > scrollLimit ? scrollLimit : proportionalTranslatePosition;
                proportionalTranslatePosition = proportionalTranslatePosition < 0 ? 0 : proportionalTranslatePosition;

                //We calculate the new bars width depending on the rail
                el._handleVerticalScrollLength();
                el._refs.verticalScroll.classList.add("vc-scroll-active");

                el._verticalUpdate(-proportionalTranslatePosition);

                if (el._misc.vertical.drag.active == true || el._misc.vertical.drag.active == "true") {
                  el._handleVerticalDrag(el._misc.mouse.clientY);
                }

                //Changes the vertical bar size depending on the new vertical scroll height
                el._refs.verticalBar.style.height = Math.ceil(parseFloat(el._refs.verticalRail.offsetHeight / (el.content.scrollHeight / el.offsetHeight))) + "px";

                vcomet.triggerCallback("onScrolled", el, el, [el._createScrollEventObject("resize")]);

              }

              //If theres no verticalScroll but we have the scroll, we will set the bar width to 100% and reposition it to fill the rail
              if (!hasVerticalScroll) {

                el._refs.verticalBar.style.height = "100%";
                el._refs.verticalBar.style.transform = "translate3d(0, 0, 0)";

                //If the scroll is not static then we remove the active class to hide it
                if (el._misc.vertical.static == false) {
                  el._refs.verticalScroll.classList.remove("vc-scroll-active");
                }

                //If the square is created and the scroll is not static we can hide it
                if (el._misc.square.created == true && el._misc.vertical.static == false) {
                  el._refs.square.classList.remove("vc-scroll-active");
                }

                if (el._misc.horizontal.created == true && el._misc.square.created == true && !el._refs.square.classList.contains("vc-scroll-active")) {
                  el._refs.horizontalScroll.style.width = '100%';
                  el._updateHorizontalBarPosition();
                }

              }

            } else if (hasVerticalScroll) {

              //If its not created then we create it
              el._setupVerticalScroll();
            }

          }

          if (el._isAllowedToHaveScroll("horizontal")) {

            //If the scroll is already created we just check if the square is active, if it is then we
            //change the scroll width to give the square the space it needs; else just give it 100%
            if (el._misc.horizontal.created == true) {

              if (hasHorizontalScroll || (!hasHorizontalScroll && el._misc.horizontal.translatePercentage != 0)) {

                var scrollLimit = el._getHorizontalScrollLimit();
                var proportionalTranslatePosition = (scrollLimit * el._misc.horizontal.translatePercentage) / 100;

                proportionalTranslatePosition = proportionalTranslatePosition > scrollLimit ? scrollLimit : proportionalTranslatePosition;
                proportionalTranslatePosition = proportionalTranslatePosition < 0 ? 0 : proportionalTranslatePosition;

                //We calculate the new bars width depending on the rail
                el._handleHorizontalScrollLength();
                el._refs.horizontalScroll.classList.add("vc-scroll-active");
                el._refs.horizontalBar.style.width = Math.ceil((el._refs.horizontalRail.offsetWidth / (el.content.scrollWidth / el.offsetWidth))) + "px";

                el._horizontalUpdate(-proportionalTranslatePosition);

                if (el._misc.horizontal.drag.active == true || el._misc.horizontal.drag.active == "true") {
                  el._handleHorizontalDrag(el._misc.mouse.clientX);
                }

                //Changes the vertical bar size depending on the new vertical scroll height
                el._refs.horizontalBar.style.width = Math.ceil(parseFloat(window.getComputedStyle(el._refs.horizontalRail, null).getPropertyValue("width").split("px")[0] / (el.content.scrollWidth / el.offsetWidth))) + "px";

                vcomet.triggerCallback("onScrolled", el, el, [el._createScrollEventObject("resize")]);

              }

              // If it doesnt have horizontal scroll we update some aspects of the scroll
              if (!hasHorizontalScroll) {

                el._refs.horizontalBar.style.width = "100%";
                el._refs.horizontalBar.style.transform = "translate3d(0, 0, 0)";

                //If the scroll is not static then we remove the active class to hide it
                if (el._misc.horizontal.static == false) {
                  el._refs.horizontalScroll.classList.remove("vc-scroll-active");
                }

                //If the square is created and the scroll is not static we can hide it
                if (el._misc.square.created == true && el._misc.vertical.static == false) {
                  el._refs.square.classList.remove("vc-scroll-active");
                }

                if (el._misc.vertical.created == true && el._misc.square.created == true && !el._refs.square.classList.contains("vc-scroll-active")) {

                  el._refs.verticalScroll.style.height = "100%";
                  el._updateVerticalBarPosition();
                }

              }

            } else if (hasHorizontalScroll) {

              //If its not created then we create it
              el._setupHorizontalScroll();
            }

          }

          el._performScroll(el._misc.horizontal.position, el._misc.vertical.position);

        }

      },

      /*
      @function (private) _handleWheelScroll
      @description Handles the scroll triggered by the mouse wheel
      @param {Object} e [Event]
      */
      handleWheelScroll: function (e) {

        var el = this;
        var scrollDelta, scrollPosition, previousPosition;

        if (vcomet.util.getBrowser() == "Firefox" && Math.abs(e.deltaY < 3)) {
          scrollDelta = (e.deltaY * 100);
          el.classList.add("active-transitions");
        } else {
          scrollDelta = vcomet.util.getBrowser() == "Firefox" ? Math.sign(e.deltaY) * 100 : e.deltaY;
          el.classList.add("active-transitions");
        }

        previousPosition = el._misc.vertical.position;

        scrollPosition = (scrollDelta < 0) ? parseInt(el._misc.vertical.position) + parseInt(Math.abs(scrollDelta)) : parseInt(el._misc.vertical.position) - parseInt(Math.abs(scrollDelta));
        scrollPosition = scrollPosition > 0 ? 0 : scrollPosition;
        scrollPosition = scrollPosition + el.content.scrollHeight < el.offsetHeight ? el.offsetHeight - el.content.scrollHeight : scrollPosition;

        // Only do something if we are actually being scrolled
        if (scrollPosition != previousPosition) {
          e.stopPropagation();
          el._animateScroll({ vertical: scrollPosition, trigger: "wheel" });
        }

      },
      /*
      @function (private) _handleVerticalDrag
      @description Handles the drag of the vertical scroll bar
      @param {Object} e [Event]
      */
      handleVerticalDrag: function (pointerY) {

        var el = this;
        var currentVerticalPosition = el._misc.vertical.position;

        var verticalRailRect = el._refs.verticalRail.getBoundingClientRect();
        var verticalBarRect = el._refs.verticalBar.getBoundingClientRect();
        var verticalBarTop = verticalBarRect.top - verticalRailRect.top;
        var barTopProportion;
        var proportionalScrollTop;

        var finalBarTopPosition;

        el.classList.remove("active-transitions");

        //Show the scrollbars when dragging, event if the mouse is outside of the scroll container
        el.showScrollbars();

        //Only do stuff when the mouse position is bigger than the verticalRail start
        if (pointerY > verticalRailRect.top) {

          //We calculate the top position of the scrollBar
          finalBarTopPosition = pointerY - verticalRailRect.top - parseFloat(el._misc.vertical.drag.start);

          //If its smaller than 0 then we just move it to the start, else if the event.clientY is bigger than the max vertical
          //movement that we can make we just set it to the bottom of the rail
          if (finalBarTopPosition < 0) {

            finalBarTopPosition = 0

          } else if (pointerY > (verticalRailRect.top + verticalRailRect.height - el._refs.verticalBar.offsetHeight + parseFloat(el._misc.vertical.drag.start))) {

            finalBarTopPosition = parseFloat(window.getComputedStyle(el._refs.verticalRail, null).getPropertyValue("height").split("px")[0] - el._refs.verticalBar.offsetHeight);
          }

          el._refs.verticalBar.style.transform = "translate3d(0, " + finalBarTopPosition + "px, 0)";

          //Here we calculate the proportional scroll that we have to make according of the scrollbar movement
          barTopProportion = (el._refs.verticalRail.offsetHeight - el._refs.verticalBar.offsetHeight) / parseFloat(verticalBarTop);
          proportionalScrollTop = parseFloat(el.content.scrollHeight - el.offsetHeight) / barTopProportion;

          el._misc.vertical.position = -proportionalScrollTop;

          el._verticalUpdate(el._misc.vertical.position);
          el._performScroll(el._misc.horizontal.position, el._misc.vertical.position);

          //If the scroll has changed we trigger the callback
          if (currentVerticalPosition != el._misc.vertical.position) {
            var eventObject = el._createScrollEventObject("drag");
            vcomet.triggerCallback("onScrolled", el, el, [eventObject]);
          }

        }

      },
      /*
      @function (private) _animateScroll
      @description Animates a scroll request and triggers onScrolled event for each animationFrame
      @param {Object} scrollObj
      */
      animateScroll: function (scrollObj) {

        var el = this;

        var verticalMovement = el._misc.vertical.position > scrollObj.vertical ? "forward" : "backward";
        var horizontalMovement = el._misc.horizontal.position > scrollObj.horizontal ? "forward" : "backward";
        var verticalPosition = scrollObj.hasOwnProperty("vertical") ? scrollObj.vertical : el._misc.vertical.position;
        var horizontalPosition = scrollObj.hasOwnProperty("horizontal") ? scrollObj.horizontal : el._misc.horizontal.position;

        var transitionEndFunction, eventObject, watcher;

        window.cancelAnimationFrame(el._misc.transition.animationFrame);
        el.content.removeEventListener("transitionend", el._misc.transition.transitionEndFunction);
        el.classList.add("active-transitions");

        el._misc.transition.ended = false;

        el._misc.transition.transitionEndFunction = function () {

          el._misc.transition.ended = true;

          setTimeout(function () {

            var triggerOnScrolled = el._misc.transition.lastVerticalPosition != Math.abs(el._misc.vertical.position) || el._misc.transition.lastHorizontalPosition != Math.abs(el._misc.horizontal.position);

            el._misc.transition.lastVerticalPosition = Math.abs(el._misc.vertical.position);
            el._misc.transition.lastHorizontalPosition = Math.abs(el._misc.horizontal.position);

            if (triggerOnScrolled) {
              vcomet.triggerCallback("onScrolled", el, el, [el._createScrollEventObject(scrollObj.trigger)]);
            }

            el.content.removeEventListener("transitionend", el._misc.transition.transitionEndFunction);

          }, 0);

        };

        el.content.addEventListener("transitionend", el._misc.transition.transitionEndFunction);

        el._verticalUpdate(verticalPosition);
        el._horizontalUpdate(horizontalPosition);

        el._performScroll(horizontalPosition, verticalPosition);

        watcher = function () {

          var currentVertical = el._getCurrentVertical(verticalMovement);
          var currentHorizontal = el._getCurrentHorizontal(horizontalMovement);

          var validVerticalForward = (verticalMovement == "forward" && currentVertical <= Math.abs(el._misc.vertical.position));
          var validVerticalBackward = (verticalMovement == "backward" && currentVertical >= Math.abs(el._misc.vertical.position));
          var validVertical = validVerticalForward || validVerticalBackward;

          var validHorizontalForward = (horizontalMovement == "forward" && currentHorizontal <= Math.abs(el._misc.horizontal.position));
          var validHorizontalBackward = (horizontalMovement == "backward" && currentHorizontal >= Math.abs(el._misc.horizontal.position));
          var validHorizontal = validHorizontalForward || validHorizontalBackward;

          var differentVertical = (typeof el._misc.transition.lastVerticalPosition != "undefined") && (el._misc.transition.lastVerticalPosition !== currentVertical);
          var differentHorizontal = (typeof el._misc.transition.lastHorizontalPosition != "undefined") && (el._misc.transition.lastHorizontalPosition !== currentHorizontal);

          if (!el._misc.transition.ended && validVertical && validHorizontal) {

            var needsForwardAvoiding = currentVertical <= el._misc.transition.lastPosition;
            var needsBackwardAvoiding = currentVertical >= el._misc.transition.lastPosition;

            eventObject = {};
            eventObject.trigger = scrollObj.trigger;
            eventObject.scrollTop = currentVertical;
            eventObject.scrollLeft = currentHorizontal;

            el.showScrollbars(el._misc.hideScrollbarsMs);

            if (differentVertical || differentHorizontal) {
              vcomet.triggerCallback("onScrolled", el, el, [eventObject]);
            }

            el._misc.transition.lastVerticalPosition = eventObject.scrollTop;
            el._misc.transition.lastHorizontalPosition = eventObject.scrollLeft;
            el._misc.transition.animationFrame = window.requestAnimationFrame(watcher);
          }

        };

        watcher();

      },
      /*
      @function (private) _performScroll
      @description Sets the required style for the content to move
      @param {Number} horizontal
      @param {Number} vertical
      */
      performScroll: function (horizontal, vertical) {
        this.content.style.transform = "translate3d(" + horizontal + "px, " + vertical + "px, 0)";
      },
      /*
      @function (private) _handleHorizontalDrag
      @description Handles the drag of the horizontal scrollbar
      @param {Object} e [Event]
      */
      handleHorizontalDrag: function (e) {

        var el = this;
        var currentHorizontalPosition = el._misc.horizontal.position;

        var horizontalRailRect = el._refs.horizontalRail.getBoundingClientRect();
        var horizontalBarRect = el._refs.horizontalBar.getBoundingClientRect();
        var horizontalBarLeft = horizontalBarRect.left - horizontalRailRect.left;
        var barLeftProportion;
        var proportionalScrollLeft;

        var finalBarLeftPosition;

        el.classList.remove("active-transitions");

        //Show the scrollbars when dragging, event if the mouse is outside of the scroll container
        el.showScrollbars();

        //Only do stuff when the mouse position is bigger than the horizontalRail start
        if (e.clientX > horizontalRailRect.left) {

          //We calculate the top position of the scrollBar
          finalBarLeftPosition = e.clientX - horizontalRailRect.left - parseFloat(el._misc.horizontal.drag.start);

          //If its smaller than 0 then we just move it to the start, else if the event.clientX is bigger than the max horizontal
          //movement that we can make we just set it to the right of the rail
          if (finalBarLeftPosition < 0) {

            finalBarLeftPosition = 0;

          } else if (e.clientX > (horizontalRailRect.left + horizontalRailRect.width - el._refs.horizontalBar.offsetWidth + parseFloat(el._misc.horizontal.drag.start))) {

            finalBarLeftPosition = parseFloat(window.getComputedStyle(el._refs.horizontalRail, null).getPropertyValue("width").split("px")[0] - el._refs.horizontalBar.offsetWidth)
          }

          el._refs.horizontalBar.style.transform = "translate3d(" + finalBarLeftPosition + "px, 0, 0)";

          //Here we calculate the proportional scroll that we have to make according of the scrollbar movement
          barLeftProportion = parseFloat(el._refs.horizontalRail.offsetWidth - el._refs.horizontalBar.offsetWidth) / (parseFloat(horizontalBarLeft))
          proportionalScrollLeft = (parseFloat(el.content.scrollWidth - el.offsetWidth) / barLeftProportion);

          el._horizontalUpdate(-proportionalScrollLeft);
          el._performScroll(el._misc.horizontal.position, el._misc.vertical.position);

          //If the scroll has changed we trigger the callback
          if (currentHorizontalPosition != el._misc.horizontal.position) {
            var eventObject = el._createScrollEventObject("drag");
            vcomet.triggerCallback("onScrolled", el, el, [eventObject]);
          }
        }
      },
      /*
      @function (private) _searchPreventScrollNodes
      @description Searches the nodes with "data-prevent-scroll" attribute to add them to our array
      */
      searchPreventScrollNodes: function () {

        var el = this;
        var preventScrollNodes = el.querySelectorAll("[data-prevent-scroll]");

        for (var i = 0; i < preventScrollNodes.length; i++) {
          el.addNodeToPreventDragScroll(preventScrollNodes[i]);
        }

      },

      /*
      @function (private) _handleVerticalScrollLength
      @description Handles the length of the vertical scroll
      */
      handleVerticalScrollLength: function () {
        var el = this;
        el._refs.verticalScroll.style.height = (el._misc.square.created && el._refs.square.classList.contains("vc-scroll-active")) ? "calc(100% - " + el.thickness + "px)" : "100%";
      },
      /*
      @function (private) _handleHorizontalScrollLength
      @description Handles the length of the vertical scroll
      */
      handleHorizontalScrollLength: function () {
        var el = this;
        el._refs.horizontalScroll.style.width = (el._misc.square.created && el._refs.square.classList.contains("vc-scroll-active")) ? "calc(100% - " + el.thickness + "px)" : "100%";
      },
      /*
      @function (private) _createVerticalScroll
      @description Creates the vertical scroll nodes structure
      */
      createVerticalScroll: function () {
        var el = this;

        var scroll = document.createElement("div");
        var rail = document.createElement("div");
        var bar = document.createElement("div");

        el._refs.verticalScroll = scroll;
        el._refs.verticalRail = rail;
        el._refs.verticalBar = bar;

        scroll.classList.add("vc-scroll-verticalScroll");
        rail.classList.add("vc-scroll-verticalRail");
        bar.classList.add("vc-scroll-verticalBar");
        bar.classList.add("vc-bg1");

        scroll.classList.add("vc-scroll-active");

        rail.appendChild(bar);
        scroll.appendChild(rail);
        el.appendChild(scroll);

        if (el._misc.vertical.static == true) {
          scroll.classList.add("vc-scroll-static");
          el.content.style.paddingRight = el.thickness + "px";
        }

        el._handleVerticalScrollLength();

        scroll.style.width = el.thickness + "px";

        if (el.arrowScrolls == true || el.arrowScrolls == "true") {
          el._createVerticalScrollArrows();
        }

      },
      /*
      @function (private) _createHorizontalScroll
      @description Creates the horizontal scroll nodes structure
      */
      createHorizontalScroll: function () {

        var el = this;

        var scroll = document.createElement("div");
        var rail = document.createElement("div");
        var bar = document.createElement("div");

        el._refs.horizontalScroll = scroll;
        el._refs.horizontalRail = rail;
        el._refs.horizontalBar = bar;

        scroll.classList.add("vc-scroll-horizontalScroll");
        rail.classList.add("vc-scroll-horizontalRail");
        bar.classList.add("vc-scroll-horizontalBar");
        bar.classList.add("vc-bg1");

        scroll.classList.add("vc-scroll-active");

        if (el._misc.horizontal.static == true) {
          scroll.classList.add("vc-scroll-static");
          el.content.style.paddingBottom = el.thickness + "px";
        }

        rail.appendChild(bar);
        scroll.appendChild(rail);
        el.appendChild(scroll);

        el._handleHorizontalScrollLength();

        scroll.style.height = el.thickness + "px";

        if (el.arrowScrolls == true || el.arrowScrolls == "true") {
          el._createHorizontalScrollArrows();
        }

      },
      /*
      @function (private) _createVerticalScrollArrows
      @description Creates the vertical arrow scrolls nodes structure
      */
      createVerticalScrollArrows: function () {

        var el = this;

        var upButton = document.createElement("div");
        var downButton = document.createElement("div");

        var upIcon = document.createElement("i");
        var downIcon = document.createElement("i");

        upIcon.classList.add("material-icons");
        upIcon.style.fontSize = el.thickness + "px";
        upIcon.innerHTML = "expand_less";

        downIcon.classList.add("material-icons");
        downIcon.style.fontSize = el.thickness + "px";
        downIcon.innerHTML = "expand_more";

        upButton.appendChild(upIcon);
        upButton.classList.add("vc-scroll-arrowButton");
        upButton.classList.add("vc-bg1");
        upButton.classList.add("vc-fg4");
        upButton.classList.add("vc-fg1-hoverable");
        upButton.classList.add("vc-unselectable");
        upButton.style.height = el.thickness + "px";
        upButton.style.width = el.thickness + "px";
        upButton.dataset.direction = "up";
        upButton.onmousedown = function (e) {
          e.preventDefault();
          el._handleArrowScroll(e, el, upButton)
        };

        downButton.appendChild(downIcon);
        downButton.classList.add("vc-scroll-arrowButton");
        downButton.classList.add("vc-bg1");
        downButton.classList.add("vc-fg4");
        downButton.classList.add("vc-fg1-hoverable");
        downButton.classList.add("vc-unselectable");
        downButton.style.height = el.thickness + "px";
        downButton.style.width = el.thickness + "px";
        downButton.dataset.direction = "down";
        downButton.addEventListener("pointerdown", function (e) {
          e.preventDefault();
          el._handleArrowScroll(e, el, downButton);
        });

        el._refs.upArrowButton = upButton;
        el._refs.downArrowButton = downButton;

        el._refs.verticalScroll.insertBefore(upButton, el._refs.verticalRail);
        el._refs.verticalScroll.appendChild(downButton);

      },
      /*
      @function (private) _createHorizontalScrollArrows
      @description Creates the horizontal arrow scrolls nodes structure
      */
      createHorizontalScrollArrows: function () {

        var el = this;

        var leftButton = document.createElement("div");
        var rightButton = document.createElement("div");

        var leftIcon = document.createElement("i");
        var rightIcon = document.createElement("i");

        leftIcon.classList.add("material-icons");
        leftIcon.style.fontSize = el.thickness + "px";
        leftIcon.innerHTML = "chevron_left";

        rightIcon.classList.add("material-icons");
        rightIcon.style.fontSize = el.thickness + "px";
        rightIcon.innerHTML = "chevron_right";

        leftButton.appendChild(leftIcon);
        leftButton.classList.add("vc-scroll-arrowButton");
        leftButton.classList.add("vc-unselectable");
        leftButton.classList.add("vc-bg1");
        leftButton.classList.add("vc-fg4");
        leftButton.classList.add("vc-fg1-hoverable");
        leftButton.style.height = el.thickness + "px";
        leftButton.style.width = el.thickness + "px";
        leftButton.dataset.direction = "left";
        leftButton.addEventListener("pointerdown", function (e) {
          e.preventDefault();
          el._handleArrowScroll(e, el, leftButton);
        });

        rightButton.appendChild(rightIcon);
        rightButton.classList.add("vc-scroll-arrowButton");
        rightButton.classList.add("vc-unselectable");
        rightButton.classList.add("vc-bg1");
        rightButton.classList.add("vc-fg4");
        rightButton.classList.add("vc-fg1-hoverable");
        rightButton.style.height = el.thickness + "px";
        rightButton.style.width = el.thickness + "px";
        rightButton.dataset.direction = "right";
        rightButton.addEventListener("pointerdown", function (e) {
          e.preventDefault();
          el._handleArrowScroll(e, el, rightButton);
        });

        el._refs.leftArrowButton = leftButton;
        el._refs.rightArrowButton = rightButton;

        el._refs.horizontalScroll.insertBefore(leftButton, el._refs.horizontalRail);
        el._refs.horizontalScroll.appendChild(rightButton);

      },
      /*
      @function (private) {object} _createScrollEventObject
      @description Creates the object for the onScrolled callback with data about the scrolling
      @param {String} trigger
      */
      createScrollEventObject: function (trigger) {

        var el = this;
        var eventObject = {};

        eventObject.trigger = trigger;
        eventObject.scrollTop = Math.abs(el._misc.vertical.position);
        eventObject.scrollLeft = Math.abs(el._misc.horizontal.position);

        return eventObject;
      },
      /*
      @function (private) _updateVerticalBarPosition
      @description Updates the vertical bar position
      @param {Number}  translatePosition
      */
      updateVerticalBarPosition: function (translatePosition) {
        var el = this;
        var scrollTopProportion, proportionalBarTop;

        translatePosition = translatePosition ? translatePosition : 1;

        scrollTopProportion = (el.content.scrollHeight - el.offsetHeight) / translatePosition;
        scrollTopProportion = scrollTopProportion < 0 ? scrollTopProportion * -1 : scrollTopProportion;

        proportionalBarTop = ((el._refs.verticalRail.offsetHeight - el._refs.verticalBar.offsetHeight) / scrollTopProportion);
        proportionalBarTop = Math.floor(proportionalBarTop) == 0 ? Math.floor(proportionalBarTop) : proportionalBarTop;

        el._refs.verticalBar.style.transform = "translate3d( 0, " + proportionalBarTop + "px, 0)";
      },
      /*
      @function (private) {Number} _getCurrentVertical
      @description Returns the current vertical content scrolling position based on the vertical bar
      */
      getCurrentVertical: function (movement) {
        var el = this;

        if (el._refs.verticalBar) {

          var verticalBarTop = -Math.abs(el._refs.verticalBar.getBoundingClientRect().top - el.getBoundingClientRect().top);
          var verticalBarScrollable = el._refs.verticalRail.offsetHeight - el._refs.verticalBar.offsetHeight;
          var scrollTopProportion = (verticalBarTop / verticalBarScrollable) * (el.content.scrollHeight.toFixed(2) - el.offsetHeight);

          return Math.abs(scrollTopProportion);

        }

        return 0;
      },
      /*
      @function (private) {Number} _getCurrentHorizontal
      @description Returns the current horizontal content scrolling position based on the horizontal bar
      */
      getCurrentHorizontal: function (movement) {
        var el = this;

        if (el._refs.horizontalBar) {

          var horizontalBarLeft = -Math.abs(el._refs.horizontalBar.getBoundingClientRect().left - el.getBoundingClientRect().left);
          var horizontalBarScrollable = el._refs.horizontalRail.offsetWidth - el._refs.horizontalBar.offsetWidth;
          var scrollLeftProportion = (horizontalBarLeft / horizontalBarScrollable) * (el.content.scrollWidth - el.offsetWidth);

          return Math.abs(scrollLeftProportion);

        }

        return 0;
      },
      /*
      @function (private) _updateHorizontalBarPosition
      @description Updates the horizontal bar position
      @param {Number} translatePosition
      */
      updateHorizontalBarPosition: function (translatePosition) {

        var el = this;
        var scrollLeftProportion, proportionalBarLeft;

        if (el._misc.horizontal.created) {

          translatePosition = translatePosition ? translatePosition : 1;

          scrollLeftProportion = (el.content.scrollWidth - el.offsetWidth) / translatePosition;
          scrollLeftProportion = scrollLeftProportion < 0 ? scrollLeftProportion * -1 : scrollLeftProportion;

          proportionalBarLeft = ((el._refs.horizontalRail.offsetWidth - el._refs.horizontalBar.offsetWidth) / scrollLeftProportion);

          el._refs.horizontalBar.style.transform = "translate3d(" + proportionalBarLeft + "px , 0, 0)";

        }

      },
      /*
      @function (private) _horizontalUpdate
      @description Updates the horizontal scroll to the given position
      @param {Number} translatePosition
      */
      horizontalUpdate: function (translatePosition) {

        var el = this;
        var scrollLimit, currentScroll, translatePercentage;

        if (el._misc.horizontal.created) {

          scrollLimit = el._getHorizontalScrollLimit();
          currentScroll = Math.abs(translatePosition) > scrollLimit ? scrollLimit : Math.abs(translatePosition);
          translatePercentage = (currentScroll / scrollLimit) * 100;

          el._misc.horizontal.position = isNaN(currentScroll) ? 0 : -Math.abs(currentScroll);
          el._misc.horizontal.translatePercentage = isNaN(translatePercentage) ? 0 : translatePercentage;

          el._updateHorizontalBarPosition(el._misc.horizontal.position);

        }

      },
      /*
      @function (private) _verticalUpdate
      @description Updates the vertical scroll to the given position
      @param {Number} translatePosition
      */
      verticalUpdate: function (translatePosition) {

        var el = this;
        var scrollLimit, currentScroll, translatePercentage;

        if (el._misc.vertical.created) {

          scrollLimit = el._getVerticalScrollLimit();
          currentScroll = Math.abs(translatePosition) > scrollLimit ? scrollLimit : Math.abs(translatePosition);
          translatePercentage = (currentScroll / scrollLimit) * 100;
          
          el._misc.vertical.position = isNaN(currentScroll) ? 0 : -Math.abs(currentScroll);
          el._misc.vertical.translatePercentage = isNaN(translatePercentage) ? 0 : translatePercentage;
          
          el._updateVerticalBarPosition(el._misc.vertical.position);

        }

      },
      /*
      @function (private) _getVerticalScrollLimit
      @description Returns the value of the vertical scroll limit
      */
      getVerticalScrollLimit: function () {

        var el = this;
        var limit;

        if (el.scrollHeight == el.offsetHeight && el.content.scrollHeight != el.content.offsetHeight) {
          limit = el.content.scrollHeight - el.content.offsetHeight;
        } else {
          limit = el.scrollHeight - el.offsetHeight;
        }
        
        return limit;
      },
      /*
      @function (private) _gethorizontalScrollLimit
      @description Returns the value of the horizontal scroll limit
      */
      getHorizontalScrollLimit: function () {

        var el = this;
        var limit;

        if (el.scrollWidth == el.offsetWidth && el.content.scrollWidth != el.content.offsetWidth) {
          limit = el.content.scrollWidth - el.content.offsetWidth;
        } else {
          limit = el.scrollWidth - el.offsetWidth;
        }

        return limit;
      },
      /*
      @function (private) {boolean} _isAllowedToHaveScroll
      @description Checks if is not restricted to the request scroll
      @param {String} scrollType
      */
      isAllowedToHaveScroll: function (scrollType) {

        var el = this;
        var returnBoolean = false;

        if (scrollType == "horizontal") {

          returnBoolean = (el.type == "auto" || el.type == "horizontal") ? true : false;

        } else if (scrollType == "vertical") {

          returnBoolean = (el.type == "auto" || el.type == "vertical") ? true : false;
        }

        return returnBoolean;
      },
      /*
      @function (private) _updateThickness
      @description Called when thickness has changed, updates everything according to the new one
      */
      updateThickness: function () {

        var el = this;

        el.content.style.paddingRight = el.pushContent == "both" || el.pushContent == "vertical" ? el.thickness + "px" : "auto";
        el.content.style.paddingBottom = el.pushContent == "both" || el.pushContent == "horizontal" ? el.thickness + "px" : "auto";

        if (el._misc.square.created) {
          el._refs.square.style.height = el.thickness + "px";
          el._refs.square.style.width = el.thickness + "px";
        }

        if (el._refs.upArrowButton) {
          el._refs.upArrowButton.style.height = el.thickness + "px";
          el._refs.upArrowButton.style.width = el.thickness + "px";
          el._refs.upArrowButton.style.fontSize = el.thickness + "px";
          el._refs.upArrowButton.querySelector("i").style.fontSize = el.thickness + "px";
        }

        if (el._refs.downArrowButton) {
          el._refs.downArrowButton.style.height = el.thickness + "px";
          el._refs.downArrowButton.style.width = el.thickness + "px";
          el._refs.downArrowButton.style.fontSize = el.thickness + "px";
          el._refs.downArrowButton.querySelector("i").style.fontSize = el.thickness + "px";
        }

        if (el._refs.leftArrowButton) {
          el._refs.leftArrowButton.style.height = el.thickness + "px";
          el._refs.leftArrowButton.style.width = el.thickness + "px";
          el._refs.leftArrowButton.style.fontSize = el.thickness + "px";
          el._refs.leftArrowButton.querySelector("i").style.fontSize = el.thickness + "px";
        }

        if (el._refs.rightArrowButton) {
          el._refs.rightArrowButton.style.height = el.thickness + "px";
          el._refs.rightArrowButton.style.width = el.thickness + "px";
          el._refs.rightArrowButton.style.fontSize = el.thickness + "px";
          el._refs.rightArrowButton.querySelector("i").style.fontSize = el.thickness + "px";
        }

        if (el._refs.verticalScroll) {
          el._refs.verticalScroll.style.width = el.thickness + "px";
          el._refs.verticalScroll.style.height = (el._misc.square.created && el._refs.square.classList.contains("vc-scroll-active")) ? "calc(100% - " + el.thickness + "px)" : "100%";
          el._refs.verticalBar.style.height = Math.ceil(parseFloat(el._refs.verticalRail.offsetHeight / (el.content.scrollHeight / el.offsetHeight))) + "px";
        }

        if (el._refs.horizontalScroll) {
          el._refs.horizontalScroll.style.height = el.thickness + "px";
          el._refs.horizontalScroll.style.width = (el._misc.square.created && el._refs.square.classList.contains("vc-scroll-active")) ? "calc(100% - " + el.thickness + "px)" : "100%";
          el._refs.horizontalBar.style.width = Math.ceil((el._refs.horizontalRail.offsetWidth / (el.content.scrollWidth / el.offsetWidth))) + "px";
        }


      },
      /*
      @function (private) _updateType
      @description Called when type has changed, removes all the scrolls and updates the scroll acording to the new one
      */
      updateType: function () {

        var el = this;

        if (el._misc.vertical.created) {
          el._refs.verticalScroll.parentNode.removeChild(el._refs.verticalScroll);
          el._misc.vertical.created = false;
        }

        if (el._misc.horizontal.created) {
          el._refs.horizontalScroll.parentNode.removeChild(el._refs.horizontalScroll);
          el._misc.horizontal.created = false;
        }

        el.update();

        if (el._misc.vertical.created) {
          el._updateVerticalBarPosition(el._misc.vertical.position);
        }

        if (el._misc.horizontal.created) {
          el._updateHorizontalBarPosition(el._misc.horizontal.position);
        }

      },
      /*
      @function (private) _forceRepaint
      @description Reassigns a display to the element as it was causing trouble on iOS not showing its content properly
      */
      forceRepaint: function () {
        var el = this;

        if (vcomet.util.getBrowser() == "Safari" && /iPad|iPhone|iPod/.test(navigator.platform)) {
          var hasStyleDisplay = (el.style.display);
          var displays = ["block", "flex"];
          var previousDisplay, newDisplay;

          previousDisplay = hasStyleDisplay ? el.style.display : window.getComputedStyle(el).display;

          displays.splice(displays.indexOf(previousDisplay), 1);
          newDisplay = displays[0];
          el.style.display = newDisplay;

          setTimeout(function () {
            el.style.display = previousDisplay;
          }, 0);
        }
      }
    },
    functions: {
      /*
      @function scrollTo
      @description Scrolls to a given position
      @param {Number} verticalPosition
      @param {Number} horizontalPosition
      @param {Boolean} transition [Whether the user wants a transition while scrolling to the request position]
      */
      scrollTo: function (verticalPosition, horizontalPosition, transition) {

        var el = this;

        if (vcomet.util.isTrue(el.getAttribute("native"))) {

          el._handleNativeScrollToRequest(verticalPosition, horizontalPosition, transition);

        } else {

          el._handleScrollToRequest(verticalPosition, horizontalPosition, transition);

        }

      },
      /*
      @function addNodeToPreventDragScroll
      @description Request from the user to add a node to the array
      @param {Object} node
     */
      addNodeToPreventDragScroll: function (node) {

        var el = this;

        if (!node.isOnPath) {
          vcomet.registerPathListener(node);
        }

        el._preventDragNodes.push(node);

      },
      /*
      @function update
      @description Public call to the resize handler, it will check if it needs to set up new scrolls or hide them
      */
      update: function () {
        this._handleScrollResize();
      },
      /*
      @function showScrollbars
      @description Shows the scrollbars
      */
      showScrollbars: function (hideScrollbarsMs) {

        var el = this;

        clearTimeout(el._misc.hideScrollbarsTimeout);

        if (el._misc.vertical.created == true && el._refs.verticalScroll.classList.contains("vc-scroll-active") == true && el._misc.vertical.static == false) {
          el._refs.verticalScroll.style.opacity = 1;
        }

        if (el._misc.horizontal.created == true && el._refs.horizontalScroll.classList.contains("vc-scroll-active") == true && el._misc.horizontal.static == false) {
          el._refs.horizontalScroll.style.opacity = 1;
        }

        if (el._misc.square.created == true && el._misc.square.static == false) {
          el._refs.square.style.opacity = 1;
        }

        if (hideScrollbarsMs) {
          el.hideScrollbars(hideScrollbarsMs);
        }

      },
      /*
      @function hideScrollbars
      @description Hides the scrollbars
      */
      hideScrollbars: function (miliseconds) {

        var el = this;

        miliseconds = miliseconds ? miliseconds : 0;

        clearTimeout(el._misc.hideScrollbarsTimeout);

        el._misc.hideScrollbarsTimeout = setTimeout(function () {

          if (el._misc.vertical.created == true && el._misc.vertical.static == false) {
            el._refs.verticalScroll.style.opacity = 0;
          }

          if (el._misc.horizontal.created == true && el._misc.horizontal.static == false) {
            el._refs.horizontalScroll.style.opacity = 0;
          }

          if (el._misc.square.created == true && el._misc.square.static == false) {
            el._refs.square.style.opacity = 0;
          }

        }, miliseconds);

      }
    },
    onCreated: function () {

      var el = this;

      // Creates a scroll callback for the user to use
      vcomet.createCallback("onScrolled", el);
      vcomet.createCallback("onHorizontalScrollCreated", el);
      vcomet.createCallback("onVerticalScrollCreated", el);

      el._initMisc();
      el._setupContent();
      el._definePublicScrollProperties();

    },
    onInit: function () {

      var el = this;

      el._setupFitSizes();
      el._setupMisc();
      el._setupContainer();
      el._moveSourceToContent();
      el._setupResizeListeners();

    },
    onRender: function () {

      var el = this;

      el.setAttribute("touch-action", "none");

      el._setupContentPush();
      el._setupBasicEvents();
      el._searchPreventScrollNodes();

    },
    onBubbleRender: function () {

      var el = this;

      el._setupContainerPosition();
      el._forceRepaint();

      vcomet.onReady(function () {
        el._setupScrollBars();
      });

    },
    onPropertyChanged: function (key, oldVal, newVal) {

      var el = this;

      if (key == "thickness") {

        el._updateThickness();

      } else if (key == "type") {

        el._updateType();

      }

    }
  });

</script>