<script>
  vcomet.element("vc-sticky", "vc-sticky.css", {
    dependencies: [
      "../vc-scroll"
    ],
    privateProperties: {
      /*
        @property (private) {Object} _misc
        @description Stores useful data information
      */
      misc: {
        value: {},
        reflect: false
      },
      /*
        @property (private) {Object} _refs
        @description Stores involved elements references
      */
      refs: {
        value: {},
        reflect: false
      }
    },
    properties: {
      /*
        @property {String} type
        @description Sticky type
        Values: fixed, absolute
        Default: fixed
      */
      type: {
        value: "fixed"
      },
      /*
        @property {String} side
        @description Sticky position type
        Values: top, bottom, right, left
        Default: top
      */
      side: {
        value: "top",
        reflect: true
      },
      /*
        @property {Number} spacing
        @description Margin between the sticky and the document limit
      */
      spacing: {
        value: 0,
        reflect: true
      },
      /*
        @property {Object} wrapper
        @description Quick access to the sticky wrapper element
      */
      wrapper: {
        value: {}
      },
      /*
        @property {String} wrapperClass
        @description Wrapper element CSS class name
      */
      wrapperClass: {
        value: "",
        reflect: true
      },
      /*
        @property {String} animationClass
        @description Custom CSS animation class
      */
      animationClass: {
        value: "",
        reflect: true
      },
      /*
        @property {Number} animPosition
        @description Scrolling breakpoint where the animation is triggered from
      */
      animPosition: {
        value: "",
        reflect: true
      },
      /*
        @property {String} vcScroll
        @description vc-scroll element query selector
      */
      vcScroll: {
        value: "",
        reflect: true
      }
    },
    privateFunctions: {
      /*
        @function {Object} (private) _wrapContent
        @description Wrap sticky content
        @return {Object} [Sticky wrapper element]
      */
      wrapContent: function () {
        var el = this;
        var wrapperFragment = document.createDocumentFragment();
        var wrapper = document.createElement("div");
        el.wrapper = wrapper;
        wrapper.classList.add("vc-sticky-stickyWrapper");
        // Check custom wrapper class
        if (el.wrapperClass) {
          wrapper.classList.add(el.wrapperClass);
        }
        // Copy size property from parent
        wrapper.style.width = el.side == "top" || el.side == "bottom" ? "100%" : el.offsetWidth + "px";
        wrapper.style.height = el.side == "top" || el.side == "bottom" ? el.offsetHeight + "px" : "100%";
        // Get source nodes
        var children = el.getSourceElements();
        // Move children nodes to the new node safely
        while (children.length) {
          // From first to last...
          wrapperFragment.appendChild(children.shift());
        }
        wrapper.appendChild(wrapperFragment);
        el.appendChild(wrapper);
        return wrapper;
      },
      /*
        @function (private) _fixedMonitor
        @description Monitor fixed behavior
      */
      fixedMonitor: function () {
        var el = this;
        if (el.type == "fixed") {
          // Apply fixed behavior for each scroll side position
          if (el.side == "top" || el.side == "left") {
            el._topLeftFixing();
          } else {
            el._bottomRightFixing();
          }
        }
      },
      /*
        @function (private) _topLeftFixing
        @description Set fixed behavior for the top and left sticky
      */
      topLeftFixing: function () {
        var el = this;
        var position = window.getComputedStyle(el.wrapper).position;
        el._misc.viewPosition -= parseInt(el.spacing);
        // Monitor fixed element behavior
        if (el.offsetParent && el._misc.viewPosition < 0 && ~["static", "relative"].indexOf(position)) {
          // Check scroll parent container
          if (el.vcScroll) {
            // Custom fixed positioning
            el._vcScrollCompatible("fixed");
          } else {
            el._nativeCompatible("fixed");
          }
        } else if (el.offsetParent && el._misc.viewPosition >= 0 && ~["fixed", "absolute"].indexOf(position)) {
          // Check scroll parent container
          if (el.vcScroll) {
            // Custom fixed positioning
            el._vcScrollCompatible("relative");
          } else {
            el._nativeCompatible("relative");
          }
        }
      },
      /*
      TODO--
        @function (private) _bottomRightFixing
        @description Set fixed behavior for bottom and right sticky
      */
      // bottomRightFixing: function () {
      //   var el = this;
      //   var body = document.documentElement || document.body;
      //   var position = window.getComputedStyle(el.wrapper).position;
      //   var limitValue = el.side == "right" ? body.offsetWidth : body.offsetHeight;
      //   // **Right value is not an exact number on IE
      //   el._misc.viewPosition = vcomet.util.getBrowser() === "IE" ? parseInt(Math.floor(el.wrapper.getBoundingClientRect()[el.side])) : el._misc.viewPosition;
      //   el._misc.viewPosition += parseInt(el.spacing);

      //   // Monitor fixed element behavior
      //   if (el.offsetParent && el._misc.viewPosition > limitValue && ["fixed", "absolute"].indexOf(position) < 0) {

      //     // Check scroll parent container
      //     if (el.vcScroll) {
      //       // Custom fixed positioning
      //       el._vcScrollCompatible("fixed");
      //     } else {
      //       el._nativeCompatible("fixed");
      //     }

      //   } else if (el.offsetParent && el._misc.viewPosition <= limitValue && ["fixed", "absolute"].indexOf(position) > -1) {

      //     // Check scroll parent container
      //     if (el.vcScroll) {
      //       // Custom fixed positioning
      //       el._vcScrollCompatible("relative");
      //     } else {
      //       el._nativeCompatible("relative");
      //     }

      //   }
      // },
      /*
        @function (private) _vcScrollCompatible
        @description Set fixed behavior inside vc-scroll container
        @param {String} position [Sticky new position value]
      */
      vcScrollCompatible: function (position) {
        var el = this;
        // Parent scroll position
        var fitSide = el.side == "top" || el.side == "bottom" ? null : "top";
        var parentScroll = document.documentElement[el._misc.scrollProp] || document.body[el._misc.scrollProp];
        // Make sticky fixed (*Sticky wrapper always turns to position absolute since it's appended on top of the DOM)
        if (position == "fixed") {
          // Append sticky wrapper to the body
          document.body.appendChild(el.wrapper);
          // Set element position "fixed"
          el.wrapper.style.position = "absolute";
          el.wrapper.style[el.side] = el.spacing + "px";
          if (fitSide) { el.wrapper.style[fitSide] = 0; }
        } else {
          // Append sticky wrapper back to the element
          el.appendChild(el.wrapper);
          // Move sticky element back to its initial position
          if (parentScroll < (el._misc.initOffsetPos - parseInt(el.spacing))) {
            el.wrapper.style.position = "relative";
            el.wrapper.style[el.side] = "0";
          }
        }
        vcomet.triggerCallback("onPositionChanged", el, el, [position == "relative" ? "relative" : "fixed"]);
      },
      /*
        @function (private) _nativeCompatible
        @description Set fixed behavior inside native scroll container
        @param {String} position [Sticky new position value]
      */
      // nativeCompatible: function (position) {
      //   var el = this;
      //   var sticky = el.wrapper;
      //   // Parent scroll position
      //   var parentScroll = document.documentElement[el._misc.scrollProp] || document.body[el._misc.scrollProp];

      //   if (position == "fixed") {
      //     // Set element position fixed
      //     sticky.style.position = "fixed";
      //     sticky.style[el.side] = el.spacing + "px";
      //     vcomet.triggerCallback("onPositionChanged", el, el, ["fixed"]);
      //   } else {
      //     // Move back sticky element to its initial position
      //     if (parentScroll < (el._misc.initOffsetPos - parseInt(el.spacing))) {
      //       sticky.style.position = "relative";
      //       sticky.style[el.side] = "auto";
      //     }
      //     vcomet.triggerCallback("onPositionChanged", el, el, ["relative"]);
      //   }
      // },
      /*
        @function (private) _animationMonitor
        @description Check the animation start position and handle it
      */
      animationMonitor: function () {
        var el = this;
        if (el.animPosition) {
          el.wrapper.style.transition = "all .2s";
          // Parent scroll position
          // *Parent is the document body element or vc-scroll if sticky is currently relative positioned
          // TODO - vc-scroll.scrollTop
          var parent = el.vcScroll && ~["static", "relative"].indexOf(window.getComputedStyle(el.wrapper).position) ? el.vcScroll : document.documentElement;
          var parentScroll = !parent.scrollTop ? 0 : parent.scrollTop;
          // Check animation scroll position
          if (!el.wrapper.classList.contains(el.animationClass) && parentScroll >= el.animPosition) {
            // Add animation class
            el.wrapper.classList.add(el.animationClass);
          } else if (el.wrapper.classList.contains(el.animationClass) && parentScroll < el.animPosition) {
            // Remove animation
            el.wrapper.classList.remove(el.animationClass);
          }
        }
      },
      /*
        @function (private) _getOffsetProp
        @description Get the distance in pixels between the element and its parent border
        @return {Number} [Element offset property value]
      */
      getOffsetProp: function () {
        var el = this;
        var prop = el.offsetTop;
        switch (el.side) {
          case "right":
            //TODO vcomet.dom.offsetRight(el);
            prop = vcomet.dom.offsetRight(el);
            break;
          case "left":
            prop = el.offsetLeft;
            break;
          case "bottom":
            //TODO vcomet.dom.offsetBottom(el);
            prop = vcomet.dom.offsetBottom(el);
            break;
        }
        return prop;
      },
      /*
        @function (private) _resizeStickyUpdate
        @description Sticky resize listener functionality
      */
      resizeStickyUpdate: function () {
        var el = this;
        // Trigger sticky event only if it is needed
        var throttled = false;
        var delay = 15;
        // Recalculate sticky initial offset position on window resize
        window.addEventListener("resize", function () {
          var position = window.getComputedStyle(el.wrapper).position;
          // Update offset value when resized on relative position
          if (el.offsetParent && position == "relative") {
            el._misc.initOffsetPos = Math.abs(el._getOffsetProp());
          }
          el.refresh();
          // Throttle
          throttled = true;
          // Set a timeout to un-throttle
          setTimeout(function () {
            throttled = false;
          }, delay);
        });
      },
      /*
        @function (private) _scrollSticky
        @description Sticky fixed monitoring
      */
      scrollSticky: function () {
        var el = this;
        // Trigger sticky event only if it is needed
        var throttled = false;
        var delay = 15;
        // Check sticky position
        el._refs.setPositionFn = function (arg) {
          if (!throttled) {
            // Get element top offset value and style top value
            el._misc.viewPosition = el.getBoundingClientRect()[el.side];
            value = Math.abs(el._getOffsetProp());
            // Fixed behavior
            el._fixedMonitor(el._misc.viewPosition, el._misc.offsetPos, el._misc.initOffsetPos, el.wrapper.style.position);
            el._animationMonitor(el._misc.viewPosition, el._misc.offsetPos, el._misc.initOffsetPos, el.wrapper.style.position);
            // Throttle
            throttled = true;
            // Set a timeout to un-throttle
            setTimeout(function () {
              throttled = false;
            }, delay);
          }
        };
        // Check scroll parent container
        if (el.vcScroll) {
          el.vcScroll.onCreated(function(){
            el.vcScroll.onScrolled(el._refs.setPositionFn);
          });
        } else {
          document.addEventListener("scroll", el._refs.setPositionFn);
        }
      }
    },
    functions: {
      /*
        @function refresh
        @description Recalculate sticky wrapper size amd update its position
      */
      refresh: function () {
        var el = this;
        // Copy size property from parent
        el.wrapper.style.width = el.side == "top" || el.side == "bottom" ? "100%" : el.offsetWidth + "px";
        el.wrapper.style.height = el.side == "top" || el.side == "bottom" ? el.offsetHeight + "px" : "100%";

        el._refs.setPositionFn.call();
      }
    },
    onCreated: function () {
      var el = this;
      vcomet.createCallback("onPositionChanged", el);
      // Store sticky information
      el._misc.scrollProp = el.side == "top" || el.side == "bottom" ? "scrollTop" : "scrollLeft";
    },
    onTransformed: function () {
      var el = this;
      // Wrap sticky content
      var sticky = el._wrapContent();
      // Get initial element distance from its parent top border 
      el._misc.initOffsetPos = el._misc.offsetPos = Math.abs(el._getOffsetProp());
      // Get element distance from viewport
      el._misc.viewPosition = sticky.getBoundingClientRect()[el.side];
      // Fixed behavior
      el.vcScroll = document.querySelector(el.vcScroll);
      if (el.vcScroll) {
        el._fixedMonitor();
      }
      // Animation monitoring
      el._animationMonitor();
      // Recalculate sticky initial offset position on window resize
      el._resizeStickyUpdate();
      // Sticky fixed functionality
      el._scrollSticky();
    },
    onPropertyChanged: function (attrName, oldVal, newVal) {
      var el = this;
      // TODO - REMOVEs
      // Monitor wrapper fixed displaying with vc-scroll integration
      // if (attrName == "_viewPosition" && el.vcScroll) {
      //   el.wrapper.style.display = newVal == -el.spacing ? "none" : "flex";
      // }
    }
  });
</script>